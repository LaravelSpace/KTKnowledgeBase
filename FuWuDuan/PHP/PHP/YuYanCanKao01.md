## PHP手册--语言参考01

### 类型

#### Boolean布尔类型

常量TRUE或FALSE，两个都不区分大小写。

当转换为boolean时，以下值被认为是FALSE：布尔值FALSE本身；整型值0（零）及-0(零)；浮点型值0.0（零）-0.0(零)；空字符串，以及字符串"0"；不包括任何元素的数组；特殊类型NULL（包括尚未赋值的变量）；从空标记生成的SimpleXML对象。所有其它值都被认为是TRUE（包括任何资源和NAN）。

#### Float浮点型

浮点数的精度有限。尽管取决于系统，PHP通常使用IEEE754双精度格式，则由于取整而导致的最大相对误差为1.11e-16。非基本数学运算可能会给出更大误差，并且要考虑到进行复合运算时的误差传递。

此外，以十进制能够精确表示的有理数如0.1或0.7，无论有多少尾数都不能被内部所使用的二进制精确表示，因此不能在不丢失一点点精度的情况下转换为二进制的格式。这就会造成混乱的结果：例如，`floor((0.1+0.7)*10)`通常会返回7而不是预期中的8，因为该结果内部的表示其实是类似7.9999999999999991118...。

所以，PHP程序里对float类型尽量做二次处理（取整数、取2位小数等），防止出现2.23变成2.229999999997这样的情况。而且，永远不要相信浮点数结果精确到了最后一位。如果确实需要更高的精度，应该使用任意精度数学函数（BCMath）或者gmp函数。

永远不要比较两个浮点数是否相等。由于内部表达方式的原因，比较两个浮点数是否相等是有问题的。但是，可以通过两个浮点数作差然后和一个仅比该数值大一点的最小误差值比较，判断两个浮点数是否相等。比如：

```php
$a = 1.23456789;
$b = 1.23456780;
$epsilon = 0.00001;
if(abs($a-$b) < $epsilon) {
    echo 'true';
}
```

某些数学运算会产生一个由常量NAN所代表的结果。此结果代表着一个在浮点数运算中未定义或不可表述的值。任何拿此值与其它任何值（除了TRUE）进行的松散或严格比较的结果都是FALSE。由于NAN代表着任何不同值，不应拿NAN去和其它值进行比较，包括其自身，应该用is_nan()来检查。

#### String字符串

一个字符串string就是由一系列的字符组成，其中每个字符等同于一个字节。这意味着PHP只能支持256的字符集，因此不支持Unicode。string最大可以达到2GB。

string中的字符可以通过一个从0开始的下标，用类似array结构中的方括号包含对应的数字来访问和修改，比如`$str[42]`。可以把string当成字符组成的array。函数substr()和substr_replace()可用于操作多于一个字符的情况。

用超出字符串长度的下标写入将会拉长该字符串并以空格填充。非整数类型下标会被转换成整数。非法下标类型会产生一个E_NOTICE级别错误。用负数下标写入字符串时会产生一个E_NOTICE级别错误，用负数下标读取字符串时返回空字符串。写入时只用到了赋值字符串的第一个字符。用空字符串赋值则赋给的值是NULL字符。

string也可用花括号访问，比如`$str{42}`。PHP的字符串在内部是字节组成的数组。因此用花括号访问或修改字符串对多字节字符集很不安全。仅应对单字节编码例如ISO-8859-1的字符串进行此类操作。

字符串可以用 '.'（点）运算符连接起来，注意 '+'（加号）运算符没有这个功能。

##### 转换成字符串

- 一个布尔值boolean的TRUE被转换成string的"1"。Boolean的FALSE被转换成""（空字符串）。这种转换可以在boolean和string之间相互进行。
- 一个整数integer或浮点数float被转换为数字的字面样式的string（包括float中的指数部分）。使用指数计数法的浮点数（4.1E+6）也可转换。
- 数组array总是转换成字符串"Array"，因此，echo和print无法显示出该数组的内容。
- 在PHP4中对象object总是被转换成字符串"Object"。为了得到对象的类的名称，可以用get_class()函数。自PHP5起，适当时可以用__toString方法。
- 资源resource总会被转变成"Resource id#1"这种结构的字符串，其中的1是PHP在运行时分配给该resource的唯一值。不要依赖此结构，可能会有变更。要得到一个resource的类型，可以用函数get_resource_type()。
- NULL总是被转变成空字符串。
- 大部分的PHP值可以转变成string来永久保存，这被称作串行化，可以用函数serialize()来实现。如果PHP引擎设定支持WDDX，PHP值也可被串行化为格式良好的XML文本。

##### 字符串转换为数值

如果该字符串没有包含'.'，'e'或'E'并且其数字值在整型的范围之内（由PHP_INT_MAX所定义），该字符串将被当成integer来取值。其它所有情况下都被作为float来取值。

如果包含字符，则该字符串的开始部分决定了它的值。如果该字符串以合法的数值开始，则使用该数值。否则其值为0（零）。合法数值由可选的正负号，后面跟着一个或多个数字（可能有小数点），再跟着可选的指数部分。指数部分由'e'或'E'后面跟着一个或多个数字构成。

```php
$foo = 1 + "10.5";                // $foo is float (11.5)
$foo = 1 + "-1.3e3";              // $foo is float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo is integer (1)
$foo = 1 + "bob3";                // $foo is integer (1)
$foo = 1 + "10 Small Pigs";       // $foo is integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
$foo = "10.0 pigs " + 1;          // $foo is float (11)
$foo = "10.0 pigs " + 1.0;        // $foo is float (11)
```

##### 字符串类型详解

PHP中的string的实现方式是一个由字节组成的数组再加上一个整数指明缓冲区长度。并无如何将字节转换成字符的信息。字符串由什么值来组成并无限制；特别的，其值为0（NUL bytes）的字节可以处于字符串任何位置（不过有几个函数，在本手册中被称为非二进制安全的，也许会把NUL字节之后的数据全都忽略）。字符串类型的此特性解释了为什么PHP中没有单独的byte类型（已经用字符串来代替了）。返回非文本值的函数（例如从网络套接字读取的任意数据）仍会返回字符串。

由于PHP并不特别指明字符串的编码，所以字符串会被按照该脚本文件相同的编码方式来编码。不过这并不适用于激活了Zend Multibyte时；此时脚本可以是以任何方式编码的（明确指定或被自动检测）然后被转换为某种内部编码，然后字符串将被用此方式编码。注意脚本的编码有一些约束（如果激活了Zend Multibyte则是其内部编码）这意味着此编码应该是ASCII的兼容超集，例如UTF-8或ISO-8859-1。不过要注意，依赖状态的编码其中相同的字节值可以用于首字母和非首字母而转换状态，这可能会造成问题。

要做到有用，操作文本的函数必须假定字符串是如何编码的。不幸的是，PHP关于此的函数有很多变种。

- 某些函数假定字符串是以单字节编码的，但并不需要将字节解释为特定的字符。例如substr()，strpos()，strlen()和strcmp()。理解这些函数的另一种方法是它们作用于内存缓冲区，即按照字节和字节下标操作。
- 某些函数被传递入了字符串的编码方式，也可能会假定默认无此信息。例如htmlentities()和mbstring扩展中的大部分函数。
- 其它函数使用了当前区域（见setlocale()），但是逐字节操作。例如strcasecmp()，strtoupper()和ucfirst()。这意味着这些函数只能用于单字节编码，而且编码要与区域匹配。例如strtoupper("á")在区域设定正确并且á是单字节编码时会返回"Á"。如果是用UTF-8编码则不会返回正确结果，其结果根据当前区域有可能返回损坏的值。
- 最后一些函数会假定字符串是使用某特定编码的，通常是UTF-8。intl扩展和PCRE（上例中仅在使用了u修饰符时）扩展中的大部分函数都是这样。尽管这是由于其特殊用途，utf8_decode()会假定UTF-8编码而utf8_encode()会假定ISO-8859-1编码。

要书写能够正确使用Unicode的程序依赖于很小心地避免那些可能会损坏数据的函数。要使用来自于intl和mbstring扩展的函数。不过使用能处理Unicode编码的函数只是个开始。不管用何种语言提供的函数，最基本的还是了解Unicode规格。例如一个程序如果假定只有大写和小写，那可是大错特错。

#### Array数组

PHP中的数组实际上是一个有序映射。映射是一种把values关联到keys的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。

数组接受任意数量用逗号分隔的键（key）=>值（value）对。PHP数组可以同时含有integer和string类型的键名，因为PHP实际并不区分索引数组和关联数组。如果指定的键名已经有了值，则该值会被覆盖，如果在数组定义中多个单元都使用了同一个键名，则只使用了最后一个，之前的都被覆盖。value可以是任意类型。

如果给出方括号但没有指定键名，则取当前最大整数索引值，新的键名将是该值加上1（但是最小为0）。如果当前还没有整数索引，则键名将为0。注意这里所使用的最大整数键名不一定当前就在数组中。它只要在上次数组重新生成索引后曾经存在过就行了。

此外key会有如下的强制转换：

- 1、包含有合法整型值的字符串会被转换为整型。例如键名"8"实际会被储存为8。但是"08"则不会强制转换，因为其不是一个合法的十进制数值。
- 2、浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名8.7实际会被储存为8。
- 3、布尔值也会被转换成整型。即键名true实际会被储存为1而键名false会被储存为0。
- 4、Null会被转换为空字符串，即键名null实际会被储存为""。
- 5、数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。

方括号和花括号可以互换使用来访问数组单元（例如`$array[42]`和`$array{42}`效果相同）。试图访问一个未定义的数组键名与访问任何未定义变量一样：会导致E_NOTICE级别错误信息，其结果为NULL。

在双引号字符串中，不给索引加上引号是合法的，因此`"$foo[bar]"`是合法的。但是强烈建议不要使用 `"$foo[bar]"`这样的写法，而要使用`"$foo['bar']"`来访问数组中元素。

unset()函数允许删除数组中的某个键。但要注意数组将不会重建索引。如果需要删除后重建索引，可以用array_values()函数。