```json
{
  "updated_by": "KelipuTe",
  "updated_at": "2020-08-04",
  "tags": "极客时间,GeekBang,后端存储实践课"
}
```

---

## 使用缓存应对高并发

### 使用缓存保护MySQL

我们知道，大部分面向公众用户的互联网系统，它的并发请求数量是和在线用户数量正相关的，而MySQL能承担的并发读写的量是有上限的，当系统的在线用户超过几万到几十万这个量级的时候，单台MySQL就很难应付了。

绝大多数互联网系统，都使用MySQL加上Redis这对儿经典的组合来解决这个问题。Redis作为MySQL的前置缓存，可以替MySQL挡住绝大部分查询请求，很大程度上缓解了MySQL并发请求的压力。但是使用缓存的时候也需要注意，一定要正确的使用缓存，如果缓存使用不当引发了缓存穿透，最终依然会导致数据库被大量查询请求打死。

### 更新缓存的最佳方式

要正确地使用好任何一个数据库，你都需要先了解它的能力和弱点，扬长避短。Redis是一个使用内存保存数据的高性能KV数据库，它的高性能主要来自于：1、简单的数据结构；2、使用内存存储数据。

数据库可以分为执行器和存储引擎两部分，Redis的执行器这一层非常的薄，所以Redis只能支持有限的几个API，几乎没有聚合查询的能力，也不支持SQL。它的存储引擎也非常简单，直接在内存中用最简单的数据结构来保存数据，你从它的API中的数据类型基本就可以猜出存储引擎中数据结构。比如，Redis的LIST在存储引擎的内存中的数据结构就是一个双向链表。

内存是一种易失性存储，所以使用内存保存数据的Redis不能保证数据可靠存储。从设计上来说，Redis牺牲了大部分功能，牺牲了数据可靠性，换取了高性能。但也正是这些特性，使得Redis特别适合用来做前置缓存。虽然说，Redis支持将数据持久化到磁盘中，并且还支持主从复制，但你需要知道，Redis仍然是一个不可靠的存储，它在设计上天然就不保证数据的可靠性，所以一般我们都使用Redis做缓存，很少使用它作为唯一的数据存储。

即使只是把Redis作为缓存来使用，我们在设计Redis缓存的时候，也必须要考虑Redis的这种“数据不可靠性”，或者换句话说，我们的程序在使用Redis的时候，要能兼容Redis丢数据的情况，做到即使Redis发生了丢数据的情况，也不影响系统的数据准确性。

很多同学都是这么用缓存的：在查询订单数据的时候，先去缓存中查询，如果命中缓存那就直接返回订单数据。如果没有命中，那就去数据库中查询，得到查询结果之后把订单数据写入缓存，然后返回。在更新订单数据的时候，先去更新数据库中的订单表，如果更新成功，再去更新缓存中的数据。

这其实是一种经典的缓存更新策略：Read/Write Through。绝大多数情况下可能都没问题。但是，在并发的情况下，有一定的概率会出现脏数据问题，缓存中的数据可能会被错误地更新成了旧数据。还有比如两个线程对同一个条订单数据并发写，也有可能造成缓存中的脏数据。这有点像数据更新时的ABA问题。

上面的这种问题用Cache Aside模式可以很好地解决，这个模式在大多数情况下是使用缓存的最佳方式。Cache Aside模式和上面的Read/Write Through模式非常像，它们处理读请求的逻辑是完全一样的，唯一的一个小差别就是，Cache Aside模式在更新数据的时候，并不去尝试更新缓存，而是去删除缓存。这条更新后的数据将在下次被访问的时候加载到缓存中。

但是Cache Aside模式并不是一定安全的，如果一个写线程在更新数据的时候，恰好赶上这条数据缓存过期，又恰好赶上一个读线程正在读这条数据，还是有可能会产生读线程将缓存更新成脏数据。这流程角度很刁钻，但是并发量大了，请求数量多了，这种情况就一定会出现。

### 注意缓存穿透引起雪崩

如果我们的缓存命中率比较低，就会出现大量缓存穿透的情况。缓存穿透指的是，在读数据的时候，没有命中缓存，请求穿透了缓存，直接访问后端数据库的情况。少量的缓存穿透是正常的，我们需要预防的是，短时间内大量的请求无法命中缓存，请求穿透到数据库，导致数据库繁忙，请求超时。大量的请求超时还会引发更多的重试请求，更多的重试请求让数据库更加繁忙，这样恶性循环导致系统雪崩。

当系统初始化的时候，比如说系统升级重启或者是缓存刚上线，这个时候缓存是空的，如果大量的请求直接打过来，很容易引发大量缓存穿透导致雪崩。为了避免这种情况，可以采用灰度发布的方式，先接入少量请求，再逐步增加系统的请求数量，直到全部请求都切换完成。

如果系统不能采用灰度发布的方式，那就需要在系统启动的时候对缓存进行预热。所谓的缓存预热就是在系统初始化阶段，接收外部请求之前，先把最经常访问的数据填充到缓存里面，这样大量请求打过来的时候，就不会出现大量的缓存穿透了。还有一种常见的缓存穿透引起雪崩的情况是，当发生缓存穿透时，如果从数据库中读取数据的时间比较长，也容易引起数据库雪崩。

所以，如果说构建缓存数据需要的查询时间太长，或者并发量特别大的时候，Cache Aside或者是Read/Write Through这两种缓存模式都可能出现大量缓存穿透。对于这种情况，并没有一种方法能应对所有的场景，你需要针对业务场景来选择合适解决方案。比如说，可以牺牲缓存的时效性和利用率，缓存所有的数据，放弃Read Through策略所有的请求，只读缓存不读数据库，用后台线程来定时更新缓存数据。



