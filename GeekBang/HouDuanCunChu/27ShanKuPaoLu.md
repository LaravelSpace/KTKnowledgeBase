```json
{
  "updated_by": "KelipuTe",
  "updated_at": "2020-08-04",
  "tags": "极客时间,GeekBang,后端存储实践课"
}
```

---

## 删库跑路怎么办

本文主要针对数据安全。虽然能够影响数据安全的事件，都是极小概率的事件。比如说：数据库宕机、磁盘损坏甚至机房着火，还有最近频繁出现在段子中的程序员删库跑路。但这些事儿一旦发生了，我们的业务就会损失惨重。

一般来说，存储系统导致的比较严重的损失主要有两种情况，一是数据丢失造成的直接财产损失，比如大量的坏账；二是由于存储系统损坏，造成整个业务系统停止服务而带来的损失。所谓防患于未然，从设计一个系统的第一天起，就需要考虑在出现各种问题的时候，可以保证系统数据的安全。

### 数据备份和恢复

保证数据安全，最简单而且有效的手段就是定期备份数据，这样出现任何问题导致的数据损失，都可以通过备份来恢复数据。最简单的备份方式就是全量备份。备份的时候，把所有的数据复制一份，存放到文件中，恢复的时候再把文件中的数据复制回去，这样可以保证恢复之后数据库中的数据和备份时是完全一样的。在MySQL中，你可以使用`mysqldump`命令来执行全量备份。比如我们要全量备份数据库test：

```mysql
$ mysqldump -uroot -p test > test.sql
```

备份出来的文件就是一个SQL文件，就是创建数据库、表，写入数据等等这些SQL，如果要恢复数据，直接执行这个备份的SQL文件就可以了：

```mysql
$ mysql -uroot test < test.sql
```

不过，**全量备份的代价非常高**。首先，备份文件包含数据库中的所有数据，占用的磁盘空间非常大；其次，每次备份操作都要拷贝大量数据，备份过程中会占用数据库服务器大量的CPU、磁盘IO资源，并且为了保证数据一致性，还有可能会锁表，这些都会导致备份期间，数据库本身的性能严重下降。所以，我们不能经常对数据库执行全量备份。那这就意味着，如果数据库中的数据丢了，那只能恢复到最近一次全量备份的那个时间点，这个时间点之后的数据还是丢了。

由于全量备份代价太高，不能频繁执行，所以理所当然的还有一种备份方式，那就是增量备份。相比于全量备份，增量备份每次只备份相对于上一次备份变化的那部分数据，所以每次增量备份速度更快。MySQL自带了Binlog，就是一种实时的增量备份。Binlog里面记录的就是MySQL数据的变更的操作日志，开启Binlog之后，我们对MySQL中的每次更新数据操作，都会被记录到Binlog中。Binlog是可以回放的，回放Binlog，就相当于把之前对数据库所有数据更新操作按照顺序重新执行了一遍。

通过定期的全量备份，配合Binlog，我们就可以把数据恢复到任意一个时间点。首先使用`show variables like '%log_bin%'`命令确认一下是否开启了Binlog功能：

```mysql
mysql> show variables like '%log_bin%';
+---------------------------------+-----------------------------------+
| Variable_name                   | Value                             |
+---------------------------------+-----------------------------------+
| log_bin                         | ON                                |
| log_bin_basename                | /usr/local/var/mysql/binlog       |
+---------------------------------+-----------------------------------+
mysql> show master status;
+---------------+----------+--------------+------------------+-------------------+
| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+---------------+----------+--------------+------------------+-------------------+
| binlog.000001 |    18745 |              |                  |                   |
+---------------+----------+--------------+------------------+-------------------+
```

可以看到当前这个数据库已经开启了Binlog，log_bin_basename表示Binlog文件在服务器磁盘上的具体位置。然后用`show master status`命令可查看当前Binlog的状态，显示正在写入的Binlog文件，及当前的位置。

假设我们每天凌晨用mysqldump做一个全量备份，然后开启了Binlog，有了这些，我们就可以把数据恢复到全量备份之后的任何一个时刻。首先执行一次全量恢复，把数据库恢复到今天凌晨的状态。

```mysql
$ mysql -uroot test < test.sql
mysql> select * from account_balance;
+---------+---------+---------------------+--------+
| user_id | balance | timestamp           | log_id |
+---------+---------+---------------------+--------+
|       0 |     100 | 2020-02-13 20:24:33 |      3 |
+---------+---------+---------------------+--------+
```

然后我们再用Binlog把数据恢复到删库跑路之前的那个时刻。

```mysql
$ mysqlbinlog --start-datetime "2020-02-20 00:00:00" --stop-datetime "2020-02-20 15:09:00" /usr/local/var/mysql/binlog.000001 | mysql -uroot

mysql> select * from account_balance;
+---------+---------+---------------------+--------+
| user_id | balance | timestamp           | log_id |
+---------+---------+---------------------+--------+
|       0 |     200 | 2020-02-20 15:08:12 |      0 |
+---------+---------+---------------------+--------+
```

通过定期的全量备份，配合 Binlog，我们就可以把数据恢复到任意一个时间点。但是在执行备份和恢复的时候，有几个要点你需要特别的注意。

第一，也是最重要的，不要把所有的鸡蛋放在同一个篮子中，无论是全量备份还是Binlog，都不要和数据库存放在同一个服务器上。离得越远越好。第二，回放Binlog的操作是具备幂等性的（为了确保回放幂等，需要设置Binlog的格式为ROW格式)。所以在回放Binlog的时候，指定的起始时间可以比全量备份的时间稍微提前一点儿，确保全量备份之后的所有操作都在恢复的Binlog范围内，这样可以保证恢复的数据的完整性。

### 配置MySQL HA实现高可用

通过全量备份加上Binlog，我们可以将数据库恢复到任何一个时间点，这样至少不会丢数据了。如果说，数据库服务器宕机了，因为我们有备份数据，完全可以启动一个新的数据库服务器，把备份数据恢复到新的数据库上，这样新的数据库就可以替代宕机的数据库，继续提供服务。但是，这个恢复数据的时间是很长的，如果数据量比较大的话，恢复的过程中，我们的系统是一直不可用的，这样肯定不行。所以我们不能等着数据库宕机了，才开始做恢复，我们可以提前来做这件事。

我们准备一台备用的数据库，把它的数据恢复成主库一样，然后实时地在主备数据库之间来同步Binlog，主库做了一次数据变更，生成一条Binlog，我们就把这一条Binlog复制到备用库并立即回放，这样就可以让备用库里面的数据和主库中的数据一直保持是一样的。一旦主库宕机，就可以立即切换到备用库上继续提供服务。这就是MySQL的高可用方案，也叫MySQL HA。MySQL自身就提供了主从复制的功能，通过配置就可以让一主一备两台MySQL的数据库保持数据同步。

但是，这个方案仍然有一些问题。当我们对主库执行一次更新操作的时候，主从两个数据库更新数据实际的时序是这样的：1、在主库的磁盘上写入Binlog；2、主库更新存储引擎中的数据；3、给客户端返回成功响应；4、主库把Binlog复制到从库；5、从库回放Binlog，更新存储引擎中的数据。

也就是说，从库的数据是有可能比主库上的数据旧一些的，这个主从之间复制数据的延迟，称为主从延迟。正常情况下，主从延迟基本都是毫秒级别，你可以认为主从就是实时保持同步的。麻烦的是不正常的情况，一旦主库或者从库繁忙的时候，有可能会出现明显的主从延迟。

而很多情况下，数据库都不是突然宕机的，而是先繁忙，性能下降，最终宕机。这种情况下，很有可能主从延迟很大，如果我们把业务直接切到从库上继续读写，主从延迟这部分数据就丢了，并且这个数据丢失是不可逆的。即使事后你找回了当时主库的Binlog也是没法做到自动恢复的，因为它和从库的数据是冲突的。

如果主库宕机并且主从存在延迟的情况下，切换到从库继续读写，可以保证业务的可用性，但是主从延迟这部分数据就丢失了。这个时候你就需要做一个选择题了，第一个选项是，保证不丢数据，牺牲可用性，暂时停止服务，想办法把主库的Binlog恢复到从库上之后再提供服务。第二个选项就是，冒着丢一些数据的风险，保证可用性，第一时间切换到从库继续提供服务。

既想要保证数据不丢，还想要做到高可用的方案，那就需要牺牲一些性能。任何好处都不可能毫无代价。既然异步复制方案不行，那就使用同步复制。MySQL本身也支持同步复制，开启同步复制时，MySQL主库会等待数据成功复制到从库之后，再给客户端返回响应。

但是这又带来了新的问题，本来从库宕机对主库是完全没影响的，因为现在主库要等待从库写入成功再返回，从库宕机，主库就会一直等待从库，主库也卡死了。这个问题的解决办法是再加一个从库，把主库配置成：成功复制到任意一个从库就返回，只要有一个从库还活着，就不会影响主库写入数据，这样就解决了从库宕机阻塞主库的问题。

如果主库发生宕机，在两个从库中，至少有一个从库中的数据是和主库完全一样的，可以把这个库作为新的主库，继续提供服务。为此你需要付出的代价是，你要至少用三台数据库服务器，并且这三台服务器提供的服务性能，还不如一台服务器高。

三种方案的优劣可以参考下面这个表。

| 方案                         | 高可用 | 可能丢数据 | 性能 |
| ---------------------------- | ------ | ---------- | ---- |
| 一主一从，异步复制，手动切换 | 否     | 可控       | 好   |
| 一主一从，异步复制，自动切换 | 是     | 是         | 好   |
| 一主二从，同步复制，自动切换 | 是     | 否         | 差   |

高可用依赖的是数据复制，数据复制的本质就是从一个库备份数据，然后恢复到另外一个库中去。数据备份时，使用低频度的全量备份配合Binlog增量备份是一种常用而且非常实用的方法，使用这种备份方法，我们可以把数据库的数据精确地恢复到历史上任意一个时刻，不仅能解决数据损坏的问题，也不用类似删库跑路这些情况了。特别要注意的是，让备份数据尽量地远离数据库。