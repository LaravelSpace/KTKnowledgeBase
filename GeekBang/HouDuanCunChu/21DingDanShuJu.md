```json
{
  "updated_by": "KelipuTe",
  "updated_at": "2020-08-03",
  "tags": "极客时间,GeekBang,后端存储实践课"
}
```

---

## 创建和更新订单时，如何保证数据准确无误？

一个合格的订单系统，最基本的要求是**数据不能错**。要达到目的其实并不难，首先保证代码没有Bug ，然后正确的使用数据库的事务，最后注意细节。注意细节很重要，**鬼知道用户会怎么用你的系统**，永远要记住这一点。

### 如何避免重复下单？

让订单服务具备**幂等性**可以避免重复下单。幂等操作的特点是，其任意多次执行所产生的影响均与一次执行的影响相同。一个幂等的创建订单服务，无论创建订单的请求发送多少次，数据库都只有一条新创建的订单记录。

可以利用数据库的**唯一约束**特性，在插入数据的时候带上**唯一识别码**，来解决创建订单服务的幂等性问题。具体的做法是给订单系统增加一个生成订单号的服务，这个服务没有参数，返回值就是一个新的、全局唯一的订单号。在用户进入创建订单的页面时，前端页面先调用这个生成订单号服务得到一个订单号，在用户提交订单的时候，在创建订单的请求中带着这个订单号。这样，无论是用户手抖，还是各种情况导致的重试，这些重复请求中带的都是同一个订单号。

### 如何解决ABA问题？

假设一个场景。订单支付之后，小二要发货，发货完成后要填个快递单号。小二填了一个单号 666，刚填完，发现填错了，赶紧再修改成888。正常情况下，订单中的快递单号会先更新成 666，再更新成888。但是不正常情况下。666请求到了，单号更新成666，然后888请求到了，单号又更新成888，但是666更新成功的响应丢了，调用方没收到成功响应，自动重试，再次发起666请求，单号又被更新成666 了，这数据显然就错了。

ABA问题有一个比较通用的解决方法。给订单主表增加一列，列名可以叫version，也即是版本号的意思。每次查询订单的时候，版本号需要随着订单数据返回给页面。页面在更新数据的请求中，需要把这个版本号作为更新请求的参数，再带回给订单更新服务。

订单服务在更新数据的时候，需要比较订单当前数据的版本号，是否和消息中的版本号一致，如果不一致就拒绝更新数据。如果版本号一致，还需要再更新数据的同时，把版本号+1。比较版本号、更新数据和版本号 +1，这个过程必须在同一个事务里面执行。通过这个版本号，就可以保证，从打开这条订单记录开始，一直到更新这条订单记录成功，这个期间没有其他人修改过这条订单数据。
