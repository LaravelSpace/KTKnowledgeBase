```json
{
  "updated_by": "KelipuTe",
  "updated_at": "2020-07-06",
  "tags": "极客时间,GeekBang,MySQL实战45讲,MySQL"
}
```

---

## 间隙锁

在45HuanDu.md中，介绍了间隙锁和next-key lock的概念，但是并没有说明加锁规则。间隙锁的概念理解起来确实有点儿难，尤其在配合上行锁以后，很容易在判断是否会出现锁等待的问题上犯错。

首先说明一下，这些加锁规则我没在别的地方看到过有类似的总结，以前我自己判断的时候都是想着代码里面的实现来脑补的。这次为了总结成不看代码的同学也能理解的规则，是我又重新刷了代码临时总结出来的。所以，这个规则有以下两条前提说明：

- MySQL后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即5.x系列<=5.7.24，8.0系列<=8.0.13。
- 如果大家在验证中有发现bad case的话，请提出来，我会再补充进这篇文章，使得一起学习本专栏的所有同学都能受益。

因为间隙锁在可重复读隔离级别下才有效，所以本篇文章接下来的描述，若没有特殊说明，默认是可重复读隔离级别。同时，可重复读隔离级别遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的时候才释放的。我总结的加锁规则里面，包含了两个原则、两个优化和一个bug。

- 原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。
- 原则2：查找过程中访问到的对象才会加锁。
- 优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。
- 优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。
- 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

我还是以上篇文章的表t为例，和你解释一下这些规则。表t的建表语句和初始化语句如下。

```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;
insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

接下来的例子基本都是配合着图片说明的，所以我建议你可以对照着文稿看，有些例子可能会毁三观，也建议你读完文章后亲手实践一下。

### 案例一：等值查询间隙锁

第一个例子是关于等值条件操作间隙：

| sessionA                       | sessionB                               | sessionC                                  |
| ------------------------------ | -------------------------------------- | ----------------------------------------- |
| begin;                         |                                        |                                           |
| update t set d=d+1 where id=7; |                                        |                                           |
|                                | insert into t values (8,8,8);(blocked) |                                           |
|                                |                                        | update t set d=d+1 where id=10;(Query OK) |

由于表t中没有id=7的记录，所以用我们上面提到的加锁规则判断一下的话：

- 根据原则1，加锁单位是next-key lock，sessionA加锁范围就是(5,10]；
- 同时根据优化2，这是一个等值查询(id=7)，而id=10不满足查询条件，next-keylock退化成间隙锁，因此最终加锁的范围是(5,10)。

所以，sessionB要往这个间隙里面插入id=8的记录会被锁住，但是sessionC修改id=10这行是可以的。

### 案例二：非唯一索引等值锁

第二个例子是关于覆盖索引上的锁：

| sessionA                                       | sessionB                                 | sessionC                               |
| ---------------------------------------------- | ---------------------------------------- | -------------------------------------- |
| begin;                                         |                                          |                                        |
| select id from t where c=5 lock in share mode; |                                          |                                        |
|                                                | update t set d=d+1 where id=5;(Query OK) |                                        |
|                                                |                                          | insert into t values (7,7,7);(blocked) |

看到这个例子，你是不是有一种该锁的不锁，不该锁的乱锁的感觉？我们来分析一下吧。这里sessionA要给索引c上c=5的这一行加上读锁。

- 根据原则1，加锁单位是next-key lock，因此会给(0,5]加上next-key lock。
- 要注意c是普通索引，因此仅访问c=5这一条记录是不能马上停下来的，需要向右遍历，查到c=10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock。
- 但是同时这个符合优化2：等值判断，向右遍历，最后一个值不满足c=5这个等值条件，因此退化成间隙锁(5,10)。
- 根据原则2，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么sessionB的update语句可以执行完成。

但sessionC要插入一个(7,7,7)的记录，就会被sessionA的间隙锁(5,10)锁住。需要注意，在这个例子中，lock in share mode只锁覆盖索引，但是如果是for update就不一样了。执行for update时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。

这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将sessionA的查询语句改成select d from t where c=5 lock in share mode。你可以自己验证一下效果。

### 案例三：主键索引范围锁

第三个例子是关于范围查询的。举例之前，你可以先思考一下这个问题：对于我们这个表t，下面这两条查询语句，加锁范围相同吗？

```mysql
mysql> select * from t where id=10 for update;
mysql> select * from t where id>=10 and id<11 for update;
```

你可能会想，id定义为int类型，这两个语句就是等价的吧？其实，它们并不完全等价。在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。现在，我们就让sessionA执行第二个查询语句，来看看加锁效果。

| sessionA                                           | sessionB                                 | sessionC                                 |
| -------------------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| begin;                                             |                                          |                                          |
| select * from t where id>=10 and id<11 for update; |                                          |                                          |
|                                                    | insert into t values(8,8,8);(Queue OK)   |                                          |
|                                                    | insert into t values(13,13,13);(blocked) |                                          |
|                                                    |                                          | update t set d=d+1 where id=15;(blocked) |

现在我们就用前面提到的加锁规则，来分析一下sessionA会加什么锁呢？

- 开始执行的时候，要找到第一个id=10的行，因此本该是next-key lock(5,10]。根据优化1，主键id上的等值条件，退化成行锁，只加了id=10这一行的行锁。
- 范围查找就往后继续找，找到id=15这一行停下来，因此需要加next-key lock(10,15]。

所以，sessionA这时候锁的范围就是主键索引上，行锁id=10和next-key lock(10,15]。这样，sessionB和sessionC的结果你就能理解了。这里你需要注意一点，首次sessionA定位查找id=10的行的时候，是当做等值查询来判断的，而向右扫描到id=15的时候，用的是范围查询判断。

### 案例四：非唯一索引范围锁

接下来，我们再看两个范围查询加锁的例子，你可以对照着案例三来看。需要注意的是，与案例三不同的是，案例四中查询语句的where部分用的是字段c。

| sessionA                                         | sessionB                              | sessionC                                |
| ------------------------------------------------ | ------------------------------------- | --------------------------------------- |
| begin;                                           |                                       |                                         |
| select * from t where c>=10 and c<11 for update; |                                       |                                         |
|                                                  | insert into t values(8,8,8);(blocked) |                                         |
|                                                  |                                       | update t set d=d+1 where c=15;(blocked) |

这次sessionA用字段c来判断，加锁规则跟案例三唯一的不同是：在第一次用c=10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终sesionA加的锁是，索引c上的(5,10]和(10,15]这两个next-key lock。

所以从结果上来看，sessonB要插入(8,8,8)的这个insert语句时就被堵住了。这里需要扫描到c=15才停止扫描，是合理的，因为InnoDB要扫到c=15，才知道不需要继续往后找了。

### 案例五：唯一索引范围锁bug

前面的四个案例，我们已经用到了加锁规则中的两个原则和两个优化，接下来再看一个关于加锁规则中bug的案例。

| sessionA                                            | sessionB                                 | sessionC                                 |
| --------------------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| begin;                                              |                                          |                                          |
| select * from t where id>=10 and id<=15 for update; |                                          |                                          |
|                                                     | update t set d=d+1 where id=20;(blocked) |                                          |
|                                                     |                                          | insert into t values(16,16,16);(blocked) |

sessionA是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并且因为id是唯一键，所以循环判断到id=15这一行就应该停止了。但是实现上，InnoDB会往前扫描到第一个不满足条件的行为止，也就是id=20。而且由于这是个范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上。

所以你看到了，sessionB要更新id=20这一行，是会被锁住的。同样地，sessionC要插入id=16的一行，也会被锁住。照理说，这里锁住id=20这一行的行为，其实是没有必要的。因为扫描到id=15，就可以确定不用往后再找了。但实现上还是这么做了，因此我认为这是个bug。

> 我也曾找社区的专家讨论过，官方 bug 系统上也有提到，但是并未被 verified。所以，认为这是 bug 这个事儿，也只能算我的一家之言，如果你有其他见解的话，也欢迎你提出来。

### 案例六：非唯一索引上存在等值的例子

接下来的例子，是为了更好地说明间隙这个概念。这里，我给表t插入一条新记录：`mysql> insert into t values(30,10,30);`。新插入的这一行c=10，也就是说现在表里有两个c=10的行。那么，这时候索引c上的间隙是什么状态了呢？你要知道，由于非唯一索引上包含主键的值，所以是不可能存在相同的两行的。

| 索引c  | 0    |      | 5    |      | 10   |      | 10   |      | 15   |      | 20   |      | 25   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 主键id | 0    |      | 5    |      | 10   |      | 30   |      | 15   |      | 20   |      | 25   |

可以看到，虽然有两个c=10，但是它们的主键值id是不同的（分别是10和30），因此这两个c=10的记录之间，也是有间隙的。图中我画出了索引c上的主键id。为了跟间隙锁的开区间形式进行区别，我用(c=10,id=30)这样的形式，来表示索引上的一行。现在，我们来看一下案例六。这次我们用delete语句来验证。注意，delete语句加锁的逻辑，其实跟select...for update是类似的，也就是我在文章开始总结的两个原则、两个优化和一个bug。

| sessionA                  | sessionB                                 | sessionC                                 |
| ------------------------- | ---------------------------------------- | ---------------------------------------- |
| begin;                    |                                          |                                          |
| delete from t where c=10; |                                          |                                          |
|                           | insert into t values(12,12,12);(blocked) |                                          |
|                           |                                          | update t set d=d+1 where c=15;(Query OK) |

这时，sessionA在遍历的时候，先访问第一个c=10的记录。同样地，根据原则1，这里加的是(c=5,id=5)到(c=10,id=10)这个next-key lock。然后，sessionA向右查找，直到碰到(c=15,id=15)这一行，循环才结束。根据优化2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成(c=10,id=10)到(c=15,id=15)的间隙锁。也就是说，这个delete语句在索引c上的加锁范围，就是下图中标记1的部分。

| 索引c  | 0    |      | 5    |      | 10   |      | 10   |      | 15   |      | 20   |      | 25   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 主键id | 0    |      | 5    |      | 10   |      | 30   |      | 15   |      | 20   |      | 25   |
|        |      |      |      | 1    | 1    | 1    | 1    | 1    |      |      |      |      |      |

这个区域左右两边都是开区间，即(c=5,id=5)和(c=15,id=15)这两行上都没有锁。

### 案例七：limit语句加锁

例子 6 也有一个对照案例，场景如下所示：

| sessionA                       | sessionB                                  |
| ------------------------------ | ----------------------------------------- |
| begin;                         |                                           |
| delete from t where c=limit 2; |                                           |
|                                | insert into t values(12,12,12);(Query OK) |

这个例子里，sessionA的delete语句加了limit2。你知道表t里c=10的记录其实只有两条，因此加不加limit2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，sessionB的insert语句执行通过了，跟案例六的结果不同。

这是因为，案例七里的delete语句明确加了limit2的限制，因此在遍历到(c=10,id=30)这一行之后，满足条件的语句已经有两条，循环就结束了。因此，索引c上的加锁范围就变成了从（c=5,id=5)到（c=10,id=30)这个前开后闭区间，如下图所示：

| 索引c  | 0    |      | 5    |      | 10   |      | 10   |      | 15   |      | 20   |      | 25   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 主键id | 0    |      | 5    |      | 10   |      | 30   |      | 15   |      | 20   |      | 25   |
|        |      |      |      | 1    | 1    | 1    | 1    |      |      |      |      |      |      |

可以看到，(c=10,id=30)之后的这个间隙并没有在加锁范围里，因此insert语句插入c=12是可以执行成功的。这个例子对我们实践的指导意义就是，**在删除数据的时候尽量加limit**。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。

### 案例八：一个死锁的例子

前面的例子中，我们在分析的时候，是按照next-key lock的逻辑来分析的，因为这样分析比较方便。最后我们再看一个案例，目的是说明：next-key lock实际上是间隙锁和行锁加起来的结果。你一定会疑惑，这个概念不是一开始就说了吗？不要着急，我们先来看下面这个例子：

| sessionA                                        | sessionB                                                     |
| ----------------------------------------------- | ------------------------------------------------------------ |
| begin;                                          |                                                              |
| select id from t where c=10 lock in share mode; |                                                              |
|                                                 | update t set d=d+1 where c=10;(blocked)                      |
| insert into t values(8,8,8);                    |                                                              |
|                                                 | ERROR 1213(40001):Deadlock found when trying to get lock;trying restarting transaction; |

现在，我们按时间顺序来分析一下为什么是这样的结果。

- sessionA启动事务后执行查询语句加 lock in share mode，在索引c上加了next-key lock(5,10]和间隙锁(10,15)；
- sessionB的update语句也要在索引c上加 next-key lock(5,10] ，进入锁等待；
- 然后sessionA要再插入(8,8,8)这一行，被sessionB的间隙锁锁住。由于出现了死锁，InnoDB 让sessionB回滚。

你可能会问，sessionB的next-key lock不是还没申请成功吗？其实是这样的，sessionB的加next-key lock(5,10]操作，实际上分成了两步，先是加(5,10)的间隙锁，加锁成功；然后加c=10的行锁，这时候才被锁住的。也就是说，我们在分析加锁规则的时候可以用next-key lock来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。

在最后的案例中，你可以清楚地知道next-key lock实际上是由间隙锁加行锁实现的。如果切换到读提交隔离级别(read-committed)的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁的部分。其实读提交隔离级别在外键场景下还是有间隙锁，相对比较复杂，我们今天先不展开。

另外，在读提交隔离级别下还有一个优化，即：语句执行过程中加上的行锁，在语句执行完成后，就要把不满足条件的行上的行锁直接释放了，不需要等到事务提交。也就是说，读提交隔离级别下，锁的范围更小，锁的时间更短，这也是不少业务都默认使用读提交隔离级别的原因。

### 思考题

我把题目重新描述和简化一下：还是我们在文章开头初始化的表 t，里面有6条记录，图12的语句序列中，为什么sessionB的insert操作，会被锁住呢？

| sessionA                                                     | sessionB                              |
| ------------------------------------------------------------ | ------------------------------------- |
| begin;                                                       |                                       |
| select * from t where c>=15 and c<=20 order by c desc lock in share mode; |                                       |
|                                                              | insert into t values(6,6,6);(blocked) |

- 由于是order by c desc，第一个要定位的是索引c上最右边的c=20的行，所以会加上间隙锁(20,25)和next-key lock(15,20]。
- 在索引c上向左遍历，要扫描到c=10才停下来，所以next-key lock会加到 (5,10]，这正是阻塞sessionB的insert语句的原因。
- 在扫描过程中，c=20、c=15、c=10这三行都存在值，由于是select *，所以会在主键id上加三个行锁。

因此，sessionA的select语句锁的范围就是：索引c上(5,25)；主键索引上id=15、20两个行锁。这里，我再啰嗦下，你会发现我在文章中，每次加锁都会说明是加在哪个索引上的。因为，锁就是加在索引上的，这是InnoDB的一个基础设定，需要你在分析问题的时候要一直记得。

### 用动态的观点看加锁

接下来，我们的讨论还是基于下面这个表 t：

```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

### 不等号条件里的等值查询

有同学对等值查询提出了疑问：等值查询和遍历有什么区别？为什么我们文章的例子里面，where条件是不等号，这个过程里也有等值查询？我们一起来看下这个例子，分析一下这条查询语句的加锁范围：

```mysql
begin;
select * from t where id>9 and id<12 order by id desc for update;
```

利用上面的加锁规则，我们知道这个语句的加锁范围是主键索引上的(0,5]、(5,10]和(10,15)。也就是说，id=15这一行，并没有被加上行锁。为什么呢？我们说加锁单位是next-key lock，都是前开后闭区间，但是这里用到了优化2，即索引上的等值查询，向右遍历的时候id=15不满足条件，所以next-key lock退化为了间隙锁(10,15)。

但是，我们的查询语句中where条件是大于号和小于号，这里的等值查询又是从哪里来的呢？要知道，加锁动作是发生在语句执行过程中的，所以你在分析加锁行为的时候，要从索引上的数据结构开始。这里，我再把这个过程拆解一下。

- 首先这个查询语句的语义是order by id desc，要拿到满足条件的所有行，优化器必须先找到第一个id<12的值。
- 这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id=12的这个值，只是最终没找到，但找到了(10,15)这个间隙。
- 然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到id=5这一行，所以会加一个next-key lock(0,5]

也就是说，在执行过程中，通过树搜索的方式定位记录的时候，用的是等值查询的方法。

### 等值查询的过程

与上面这个例子对应的，下面这个语句的加锁范围是什么？

```mysql
begin;
select id from t where c in(5,20,10) lock in share mode;
```

这条查询语句里用的是in，我们先来看这条语句的explain结果。

![](E:\GongZuoQu\KTZhiShiKu\Image\GeekBang\MySQLShiZhan\JianXiSuo_img12.png)

可以看到，这条in语句使用了索引c并且rows=3，说明这三个值都是通过B+树搜索定位的。在查找c=5的时候，先锁住了(0,5]。但是因为c不是唯一索引，为了确认还有没有别的记录c=5，就要向右遍历，找到c=10才确认没有了，这个过程满足优化2，所以加了间隙锁(5,10)。

同样的，执行c=10这个逻辑的时候，加锁的范围是(5,10]和(10,15)；执行c=20这个逻辑的时候，加锁的范围是(15,20]和(20,25)。通过这个分析，我们可以知道，这条语句在索引c上加的三个记录锁的顺序是：先加c=5的记录锁，再加c=10的记录锁，最后加c=20的记录锁。

你可能会说，这个加锁范围，不就是从(5,25)中去掉c=15的行锁吗？为什么这么麻烦地分段说呢？因为我要跟你强调这个过程：这些锁是在执行过程中一个一个加的，而不是一次性加上去的。理解了这个加锁过程之后，我们就可以来分析下面例子中的死锁问题了。

如果同时有另外一个语句，是这么写的：`select id from t where c in(5,20,10) order by c desc for update;`。此时的加锁范围，又是什么呢？我们现在都知道间隙锁是不互锁的，但是这两条语句都会在索引c上的c=5、10、20这三行记录上加记录锁。这里你需要注意一下，由于语句里面是order by c desc，这三个记录锁的加锁顺序，是先锁c=20，然后c=10，最后是c=5。

也就是说，这两条语句要加锁相同的资源，但是加锁顺序相反。当这两条语句并发执行的时候，就可能出现死锁。关于死锁的信息，MySQL只保留了最后一个死锁的现场，但这个现场还是不完备的。现在，我就来简单分析一下上面这个例子的死锁现场。

### 怎么看死锁

图是在出现死锁后，执行show engine innodb status命令得到的部分输出。这个命令会输出很多信息，有一节LATESTDETECTED DEADLOCK，就是记录的最后一次死锁信息。

![](E:\GongZuoQu\KTZhiShiKu\Image\GeekBang\MySQLShiZhan\JianXiSuo_img14.png)

我们来看看这图中的几个关键信息。

1、这个结果分成三部分：

- (1) TRANSACTION，是第一个事务的信息；
- (2) TRANSACTION，是第二个事务的信息；
- WE ROLL BACK TRANSACTION (1)，是最终的处理结果，表示回滚了第一个事务。

2、第一个事务的信息中：

- WAITING FOR THIS LOCK TO BE GRANTED，表示的是这个事务在等待的锁信息；
- index c of table test.t，说明在等的是表t的索引c上面的锁；
- lock mode S waiting 表示这个语句要自己加一个读锁，当前的状态是等待中；
- Record lock 说明这是一个记录锁；
- n_fields 2 表示这个记录是两列，也就是字段c和主键字段id；
- 0: len 4; hex 0000000a; asc ;; 是第一个字段，也就是c。值是十六进制a，也就是10；
- 1: len 4; hex 0000000a; asc ;; 是第二个字段，也就是主键id，值也是10；
- 这两行里面的asc表示的是，接下来要打印出值里面的可打印字符，但10不是可打印字符，因此就显示空格。
- 第一个事务信息就只显示出了等锁的状态，在等待(c=10,id=10)这一行的锁。
- 当然你是知道的，既然出现死锁了，就表示这个事务也占有别的锁，但是没有显示出来。别着急，我们从第二个事务的信息中推导出来。

3、第二个事务显示的信息要多一些：

- HOLDS THE LOCK(S)用来显示这个事务持有哪些锁；
- index c of table test.t表示锁是在表t的索引c上；
- hex 0000000a 和 hex 00000014 表示这个事务持有c=10和c=20这两个记录锁；
- WAITING FOR THIS LOCK TO BE GRANTED，表示在等(c=5,id=5)这个记录锁。

从上面这些信息中，我们就知道：

- lock in share mode的这条语句，持有c=5的记录锁，在等c=10的锁；
- for update这个语句，持有c=20和c=10的记录锁，在等c=5的记录锁。

因此导致了死锁。这里，我们可以得到两个结论：

- 由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；
- 在发生死锁的时刻，for update这条语句占有的资源更多，回滚成本更大，所以InnoDB选择了回滚成本更小的lock in share mode语句，来回滚。

## 怎么看锁等待

看完死锁，我们再来看一个锁等待的例子。

| sessionA                                           | sessionB                                 |
| -------------------------------------------------- | ---------------------------------------- |
| begin;                                             |                                          |
| select * from t where id>10 and id<=15 for update; |                                          |
|                                                    | delete from t where id=10;(Query OK)     |
|                                                    | insert into t values(10,10,10);(blocked) |

可以看到，由于sessionA并没有锁住c=10这个记录，所以sessionB删除id=10这一行是可以的。但是之后，sessionB再想insert id=10这一行回去就不行了。现在我们一起看一下此时show engine innodb status的结果，看看能不能给我们一些提示。锁信息是在这个命令输出结果的TRANSACTIONS这一节。

![](E:\GongZuoQu\KTZhiShiKu\Image\GeekBang\MySQLShiZhan\JianXiSuo_img16.png)

我们来看几个关键信息。

1、index PRIMARY of table test.t ，表示这个语句被锁住是因为表t主键上的某个锁。

2、lock_mode X locks gap before rec insert intention waiting 这里有几个信息：

- insert intention 表示当前线程准备插入一个记录，这是一个插入意向锁。为了便于理解，你可以认为它就是这个插入动作本身。
- gap before rec 表示这是一个间隙锁，而不是记录锁。

3、那么这个 gap 是在哪个记录之前的呢？接下来的0~4这5行的内容就是这个记录的信息。

4、n_fields 5也表示了，这一个记录有5列：

- 0: len 4; hex 0000000f; asc ;; 第一列是主键id字段，十六进制f就是id=15。所以，这时我们就知道了，这个间隙就是id=15之前的，因为id=10已经不存在了，它表示的就是(5,15)。
- 1: len 6; hex 000000000513; asc ;; 第二列是长度为6字节的事务id，表示最后修改这一行的是trx id 为1299的事务。
- 2: len 7; hex b0000001250134; asc % 4;; 第三列长度为7字节的回滚段信息。可以看到，这里的 acs 后面有显示内容 (% 和 4)，这是因为刚好这个字节是可打印字符。
- 后面两列是c和d的值，都是15。

因此，我们就知道了，由于delete操作把id=10这一行删掉了，原来的两个间隙(5,10)、(10,15）变成了一个(5,15)。

说到这里，你可以联合起来再思考一下这两个现象之间的关联：

- sessionA执行完select语句后，什么都没做，但它加锁的范围突然变大了；
- 当我们执行`select * from t where  c>=15 and c<=20 order by c desc lock in share mode;`向左扫描到c=10的时候，要把(5,10]锁起来。

也就是说，所谓间隙，其实根本就是由这个间隙右边的那个记录定义的。

## update的例子

看过了insert和delete的加锁例子，我们再来看一个update语句的案例。

| sessionA                                      | sessionB                              |
| --------------------------------------------- | ------------------------------------- |
| begin;                                        |                                       |
| select c from t where c>5 lock in share mode; |                                       |
|                                               | update t set c=1 where c=5;(Query OK) |
|                                               | update t set c=5 where c=1;(blocked)  |

你可以自己分析一下，sessionA的加锁范围是索引c上的(5,10]、(10,15]、(15,20]、(20,25]和(25,supremum]。注意：根据c>5查到的第一个记录是c=10，因此不会加(0,5]这个next-key lock。之后sessionB的第一个update语句，要把c=5改成c=1，你可以理解为两步：插入(c=1,id=5)这个记录；删除(c=5,id=5)这个记录。

按照我们上一节说的，索引c上(5,10)间隙是由这个间隙右边的记录，也就是c=10定义的。所以通过这个操作，sessionA的加锁范围变成了图示下标1的样子，开区间：

| 索引c  | 0    |      | 1    |      | 10   |      | 15   |      | 20   |      | 25   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 主键id | 0    |      | 5    |      | 10   |      | 15   |      | 20   |      | 25   |
|        |      |      |      | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |

好，接下来sessionB要执行`update t set c = 5 where c = 1`这个语句了，一样地可以拆成两步：插入(c=5,id=5)这个记录；删除(c=1,id=5)这个记录。第一步试图在已经加了间隙锁的(1,10)中插入数据，所以就被堵住了。