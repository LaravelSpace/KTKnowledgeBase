## 阻塞

### Redis实例的阻塞点

Redis实例在运行时，要和许多对象进行交互，这些不同的交互就会涉及不同的操作。

![](E:\GongZuoQu\ZhiShiKu\TuPian\JiKeShiJian\Redis\ZuSe_img02.jpg)

### 和客户端交互时的阻塞点

网络IO有时候会比较慢，但是Redis使用了IO多路复用机制，避免了主线程一直处在等待网络连接或请求到来的状态，所以，网络IO不是导致Redis阻塞的因素。

键值对的增删改查操作是Redis和客户端交互的主要部分，也是Redis主线程执行的主要任务。所以，复杂度高的增删改查操作肯定会阻塞Redis。这里有一个最基本的标准，就是看操作的复杂度是否为O(N)，比如集合全量查询和聚合操作。

除此之外，集合自身的删除操作同样也有潜在的阻塞风险。删除操作的本质是要释放键值对占用的内存空间，释放内存只是第一步。为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。

所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成Redis主线程的阻塞。最典型的就是删除包含了大量元素的集合，也称为bigkey删除。

| 集合类型   | 10万（8字节） | 100万（8字节） | 10万（128字节） | 100万（128字节） |
| ---------- | ------------- | -------------- | --------------- | ---------------- |
| Hash       | 50ms          | 962ms          | 91ms            | 1980ms           |
| List       | 25ms          | 133ms          | 29ms            | 283ms            |
| Set        | 42ms          | 821ms          | 75ms            | 1347ms           |
| Sorted Set | 53ms          | 809ms          | 61ms            | 991ms            |

既然频繁删除键值对都是潜在的阻塞点了，那么，在Redis的数据库级别操作中，清空数据库（例如FLUSHDB和FLUSHALL操作）必然也是一个潜在的阻塞风险，因为它涉及到删除和释放所有的键值对。

### 和磁盘交互时的阻塞点

Redis设计为采用子进程的方式执行AOF日志重写操作，以及生成RDB快照文件。这两个操作由子进程负责执行，所以，慢速的磁盘IO不会阻塞主线程。但是，Redis直接记录AOF日志时，会根据不同的写回策略对数据做落盘保存。一个同步写磁盘的操作的耗时大约是1～2ms，如果有大量的写操作需要记录在AOF日志中，并同步写回的话，就会阻塞主线程。

### 主从节点交互时的阻塞点

在主从集群中，主库需要生成RDB文件，并传输给从库。主库在复制的过程中，创建和传输RDB文件都是由子进程来完成的，不会阻塞主线程。但是，对于从库来说，它在接收了RDB文件后，需要使用FLUSHDB命令清空当前数据库。

此外，从库在清空当前数据库后，还需要把RDB文件加载到内存，这个过程的快慢和RDB文件的大小密切相关，RDB文件越大，加载过程越慢，所以，加载RDB文件也会阻塞主进程。

### 切片集群实例交互时的阻塞点

当部署Redis切片集群时，每个Redis实例上分配的哈希槽信息需要在不同实例间进行传递，同时，当需要进行负载均衡或者有实例增删时，数据会在不同的实例间进行迁移。不过，哈希槽的信息量不大，而数据迁移是渐进式执行的，所以，一般来说，这两类操作对Redis主线程的阻塞风险不大。

不过，如果你使用了Redis Cluster方案，而且同时正好迁移的是bigkey的话，就会造成主线程的阻塞，因为Redis Cluster使用了同步迁移。当没有bigkey时，切片集群的各实例在进行交互时不会阻塞主线程。

### 哪些阻塞点可以异步执行

如果一个操作能被异步执行，就意味着，它并不是Redis主线程的关键路径上的操作。

- 对于Redis来说，读操作是典型的关键路径操作，因为客户端发送了读操作之后，就会等待读取的数据返回，以便进行后续的数据处理。
- 删除操作并不需要给客户端返回具体的数据结果，所以不算是关键路径操作。
- 为了保证数据可靠性，Redis实例需要保证AOF日志中的操作记录已经落盘，这个操作虽然需要实例等待，但它并不会返回具体的数据结果给实例，可以启动一个子线程来执行AOF日志的同步写。
- 从库要想对客户端提供数据存取服务，就必须把RDB文件加载完成。所以，这个操作也属于关键路径上的操作，必须让从库的主线程来执行。

### 异步的子线程机制

Redis主线程启动后，会使用操作系统提供的pthread_create函数创建3个子线程，分别由它们负责AOF日志写操作、键值对删除以及文件关闭的异步执行。主线程通过一个链表形式的任务队列和子线程进行交互。

当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。但实际上，这个时候删除还没有执行，等到后台子线程从任务队列中读取任务后，才开始实际删除键值对，并释放相应的内存空间。因此，这种异步删除也称为惰性删除（lazy free）。此时，删除或清空操作不会阻塞主线程，这就避免了对主线程的性能影响。

和惰性删除类似，当AOF日志配置成everysec选项后，主线程会把AOF写日志操作封装成一个任务，也放到任务队列中。后台子线程读取任务后，开始自行写入AOF日志，这样主线程就不用一直等待AOF日志写完了。

注意一下，异步的键值对删除和数据库清空操作是Redis4.0后提供的功能，Redis也提供了新的命令来执行这两个操作。1、键值对删除：当集合类型中有大量元素（例如有百万级别或千万级别元素）需要删除时，建议使用UNLINK命令。2、清空数据库：可以在FLUSHDB和FLUSHALL命令后加上ASYNC选项，这样就可以让后台子线程异步地清空数据库。
