## 统计

在Web和移动应用的业务场景中，经常需要保存一个key对应一个集合的这种类型的信息。并且还需要对这些信息进行分析。常见的有：用户登录信息，评论列表信息，用户签到信息，用户访问信息等。

通常情况下，我们面临的用户数量以及访问量都是巨大的，比如百万、千万级别的用户数量，甚至亿级别的访问信息。所以，必须要选择能够非常高效地统计大量数据（例如亿级）的集合类型。要想选择合适的集合，我们就得了解常用的集合统计模式。常见的统计模式有四种，包括聚合统计、排序统计、二值状态统计和基数统计。

### 聚合统计

所谓的聚合统计，就是指统计多个集合元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素（并集统计）。

比如，如果想统计第二天新增用户数量和第二天的留存用户数量，就可以使用聚合统计。首先我们需要一个集合来保存一天中登录过的用户的ID，这里直接使用Set集合就可以。

先求第二天之前的所有天的用户登录ID集合的并集得到累计登录用户ID集合，然后求第二天用户登录ID集合和累计登录用户ID集合的差集，就可以得到第二天新增用户ID集合。求第二天的用户登录ID集合和前一天的用户登录ID集合的交集，就可以得到第二天的留存用户。

这里需要注意的是Set的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致Redis实例阻塞。所以，可以从主从集群中选择一个从库，让它专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计，这样就可以规避阻塞主库实例和其他从库实例的风险了。

### 排序统计

在Redis常用的4个集合类型中（List、Hash、Set、Sorted Set），List和Sorted Set就属于有序集合。List是按照元素进入List的顺序进行排序的，而Sorted Set可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。

但是List有一个问题，List是通过元素在List中的位置来排序的，当有一个新元素插入时，原先的元素在List中的位置都后移了一位，比如说原来在第1位的元素现在排在了第2位。所以，对比新元素插入前后，List相同位置上的元素就会发生变化，用LRANGE读取时，就会读到旧元素。和List相比，Sorted Set就不存在这个问题，因为它是根据元素的实际权重来排序和获取数据的。

Sorted Set的ZRANGEBYSCORE命令就可以按权重排序后返回元素。这样的话，即使集合中的元素频繁更新，Sorted Set也能通过ZRANGEBYSCORE命令准确地获取到按序排列的数据。假设越新的记录权重越大，目前最新记录的权重是N，执行`ZRANGEBYSCORE comments N-9 N`命令时，就可以获得最新的10条记录。所以，在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议优先考虑使用Sorted Set。

### 二值状态统计

这里的二值状态就是指集合元素的取值就只有0和1两种。在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。在签到统计时，每个用户一天的签到用1个bit位就能表示，一个月（假设是31天）的签到情况用31个bit位就可以，而一年的签到也只需要用365个bit位，根本不用太复杂的集合类型。这个时候，就可以选择Bitmap。这是Redis提供的扩展数据类型。

Bitmap本身是用String类型作为底层数据结构实现的一种统计二值状态的数据类型。String类型是会保存为二进制的字节数组，所以，Redis就把字节数组的每个bit位利用起来，用来表示一个元素的二值状态。可以把Bitmap看作是一个bit数组。

Bitmap提供了GETBIT/SETBIT操作，使用一个偏移值offset对bit数组的某一个bit位进行读和写。不过，需要注意的是，Bitmap的偏移量是从0开始算的，也就是说offset的最小值是0。当使用SETBIT对一个bit位进行写操作时，这个bit位会被设置为1。Bitmap还提供了BITCOUNT操作，用来统计这个bit数组中所有1的个数。

Bitmap支持用BITOP命令对多个Bitmap按位做与或异或的操作，操作的结果会保存到一个新的Bitmap中。这个特性可以用来解决统计1亿个用户连续10天的签到情况。可以把每天的日期作为key，每个key对应一个1亿位的Bitmap，每一个bit对应一个用户当天的签到情况。接下来，对10个Bitmap做与操作，得到的结果也是一个Bitmap。在这个Bitmap中，只有10天都签到的用户对应的bit位上的值才会是1。最后，我们可以用BITCOUNT统计下Bitmap中的1的个数，这就是连续签到10天的用户总数了。

### 基数统计

基数统计就是指统计一个集合中不重复的元素个数。对应到实际使用的场景中，就是统计网页的UV。网页UV的统计有个独特的地方，就是需要去重，一个用户一天内的多次访问只能算作一次。在Redis的集合类型中，Set类型默认支持去重，所以看到有去重需求时，可能第一时间就会想到用Set类型。除了Set还可以用Hash集合。

但是不管是Set集合还是Hash集合，都会消耗很大的内存空间。所以Redis提供了HyperLogLog。HyperLogLog是一种用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小。

不过，需要注意的是，HyperLogLog的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是0.81%。这也就意味着，你使用HyperLogLog统计的UV是100万，但实际的UV可能是101万。虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用Set或Hash类型。

![](E:\GongZuoQu\ZhiShiKu\TuPian\JiKeShiJian\Redis\TongJi_img02.jpg)