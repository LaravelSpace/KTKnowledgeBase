## 并发访问

在使用Redis时，不可避免地会遇到并发访问的问题。一旦有了并发写操作，数据就会被修改，如果没有对并发写请求做好控制，就可能导致数据被改错，影响到业务的正常使用。为了保证并发访问的正确性，Redis提供了两种方法，分别是加锁和原子操作。

加锁是一种常用的方法，在读取数据前，客户端需要先获得锁，否则就无法进行操作。当一个客户端获得锁后，就会一直持有这把锁，直到客户端完成数据更新，才释放这把锁。看上去好像是一种很好的方案，但是，其实这里会有两个问题：一个是，如果加锁操作多，会降低系统的并发访问性能；第二个是，Redis客户端要加锁时，需要用到分布式锁，而分布式锁实现复杂，需要用额外的存储系统来提供加解锁操作。

原子操作是另一种提供并发访问控制的方法。原子操作是指执行过程保持原子性的操作，而且原子操作执行时并不需要再加锁，实现了无锁操作。这样一来，既能保证并发控制，还能减少对系统并发性能的影响。

### 并发访问中需要控制的对象

并发访问控制，是指对多个客户端访问操作同一份数据的过程进行控制，以保证任何一个客户端发送的操作在Redis实例上执行时具有互斥性。例如，客户端A的访问操作在执行时，客户端B的操作不能执行，需要等到A的操作结束后，才能执行。

并发访问控制对应的操作主要是数据修改操作。当客户端需要修改数据时，基本流程分成两步：1、客户端先把数据读取到本地，在本地进行修改；2、客户端修改完数据后，再写回Redis。

这个流程叫做读取-修改-写回操作（Read-Modify-Write，简称为RMW操作）。当有多个客户端对同一份数据执行RMW操作的话，就需要让RMW操作涉及的代码以原子性方式执行。访问同一份数据的RMW操作代码，就叫做临界区代码。不过，当有多个客户端并发执行临界区代码时，就会存在一些潜在问题。

| 时间 | 客户端A       | Redis  | 客户端B       |
| ---- | ------------- | ------ | ------------- |
| t1   | 读取库存并减1 | 库存10 |               |
| t2   |               | 库存10 | 读取库存并减1 |
| t3   | 写回库存9     | 库存9  |               |
| t4   |               | 库存9  | 写回库存9     |

出现这个现象的原因是，临界区代码中的客户端读取数据、更新数据、再写回数据涉及了三个操作，而这三个操作在执行时并不具有互斥性，多个客户端基于相同的初始值进行修改，而不是基于前一个客户端修改后的值再修改。

为了保证数据并发修改的正确性，可以用锁把并行操作变成串行操作，串行操作就具有互斥性。一个客户端持有锁后，其他客户端只能等到锁释放，才能拿锁再进行修改。虽然加锁保证了互斥性，但是加锁也会导致系统并发性能降低。

| 时间 | 客户端A    | 客户端B    | 客户端C |
| ---- | ---------- | ---------- | ------- |
| t1   | 拿锁，执行 | 等待       | 等待    |
| t2   | 释放锁     | 拿锁，执行 | 等待    |

### Redis的原子操作

为了实现并发控制要求的临界区代码互斥执行，Redis的原子操作采用了两种方法：1、把多个操作在Redis中实现成一个操作，也就是单命令操作；2、把多个操作写到一个Lua脚本中，以原子性方式执行单个Lua脚本。

Redis是使用单线程来串行处理客户端的请求操作命令的，所以，当Redis执行某个命令操作时，其他命令是无法执行的，这相当于命令操作是互斥执行的。当然，Redis的快照生成、AOF重写这些操作，可以使用后台线程或者是子进程执行，也就是和主线程的操作并行执行。不过，这些操作只是读取数据，不会修改数据，所以，并不需要对它们做并发控制。

虽然Redis的单个命令操作可以原子性地执行，但是在实际应用中，数据修改时可能包含多个操作，至少包括读数据、数据增减、写回数据三个操作，这显然就不是单个命令操作了。所以Redis提供了INCR/DECR命令，把这三个操作转变为一个原子操作了。INCR/DECR命令可以对数据进行增值/减值操作，而且它们本身就是单个命令操作，Redis在执行它们时，本身就具有互斥性。

但是，如果要执行的操作不是简单地增减数据，而是有更加复杂的判断逻辑或者是其他操作，那么，Redis的单命令操作已经无法保证多个操作的互斥执行了。所以，这个时候，们需要使用第二个方法，也就是Lua脚本。

Redis会把整个Lua脚本作为一个整体执行，在执行的过程中不会被其他命令打断，从而保证了Lua脚本中操作的原子性。如果有多个操作要执行，但是又无法用INCR/DECR这种命令操作来实现，就可以把这些要执行的操作编写到一个Lua脚本中。然后，可以使用Redis的EVAL命令来执行脚本。这样一来，这些操作在执行时就具有了互斥性。值得注意的是，在编写 Lua 脚本时，要避免把不需要做并发控制的操作写入脚本中。