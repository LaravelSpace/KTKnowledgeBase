## LeetCode701-750题

### [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

给两个整数数组A和B ，返回两个数组中公共的、长度最长的子数组的长度。

示例：

```
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。
```

提示：

```
1 <= len(A), len(B) <= 1000
0 <= A[i], B[i] < 100
```

问题分析：

这题可以使用动态规划的方法，反过来思考，从末尾开始。比较A[i]和B[j] ，记问题的结果为`dp[i][j]`。无论A[i]和B[j]相不相同，问题的结果`dp[i][j]`都依赖于，数组A的A[i]的前面的部分和数组B的B[j] 的前面的部分关于此问题的结果即`dp[i-1][j-1]`。

如果最后一位一样，那么结果一定是要带着最后一位的，所以问题就转换成求解`dp[i-1][j-1]`了。比如1232和32的解等于123和3的解+1。如果最后一位不一样，那么结果等于这两个数组往前找，直到找到最后一位一样的那个情况的解。比如1232和3214的解就等于1232和32的解。

下面给出的是状态转移表（第一列表示A数组，第一行表示B数组）。比如，{A2,B2}这个位置的结果，就依赖于{A1,B1}这个位置的结果，表示[3,2]和[1,2]的最长公共子数组的结果依赖[3]和[1]的最长公共子数组的结果。另外，{A2,B1}这个位置的结果，可以理解成依赖于{A1,B0}也就是[3]和[]的结果，[3]和[]的结果当然是0。

|      | 3    | 2    | 1    | 4    | 7    |
| :--- | ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 0    | 1    | 0    | 0    |
| 2    | 0    | 1    | 0    | 0    | 0    |
| 3    | 1    | 0    | 0    | 0    | 0    |
| 2    | 0    | 2    | 0    | 0    | 0    |
| 1    | 0    | 0    | 3    | 0    | 0    |

代码参考：CYangLi/leetcode/leetcode718.c
