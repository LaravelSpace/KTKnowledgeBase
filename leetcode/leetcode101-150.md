## LeetCode101-150题

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明：叶子节点是指没有子节点的节点。

示例：给定二叉树 [3,9,20,null,null,15,7]，返回它的最大深度 3 。

     3
    / \
    9  20
      /  \
     15   7

问题分析：用队列的方式进行层次遍历。

代码参考：CYangLi/leetcode/leetcode104.c

### [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：给定二叉树 [3,9,20,null,null,15,7],

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其自底向上的层次遍历为：

```
[
  [15,7],
  [9,20],
  [3]
]
```

问题分析：使用广度优先(层次)遍历，分层记录每一层的遍历结果。结果的层次顺序是反的，最后需要把数组倒过来。

代码参考：CYangLi/leetcode/leetcode107.c

### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

给你一个整数数组nums，其中元素已经按升序排列，请你将其转换为一棵高度平衡二叉搜索树。高度平衡二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过1」的二叉树。

示例：

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案
```

提示：

    1 <= nums.length <= 104
    -104 <= nums[i] <= 104
    nums 按 严格递增 顺序排列

问题分析：数组已经有序了，那么从有序数组从中间一分为二，左边的一半都比中间值小，右边的一半都比中间值大。然后递归操作处理每一段。

代码参考：CYangLi/leetcode/leetcode108.c

### [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

给定一个非负整数numRows，生成杨辉三角的前numRows行。在杨辉三角中，每个数是它左上方和右上方的数的和。

示例：

```
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

代码参考：CYangLi/leetcode/leetcode118.c

### [119. 杨辉三角II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

给定一个非负索引k，其中k≤33，返回杨辉三角的第k行。

进阶：你可以优化你的算法到O(k)空间复杂度吗？

代码参考：CYangLi/leetcode/leetcode119.c

### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 prices ，它的第i个元素prices[i]表示一支给定股票第i天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。


示例:

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
     
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

问题分析：

画个价格折线图，更有利于理解。

记录最大利润和最小买入价格。因为卖出价格一定时，买入价格越低利润越大。所以每次循环，计算利润并和最大利润比较，如果发现更小买入价格就更新最小买入价格。位于前面的最小买入价格的结果将会保存在最大利润中，位于后面的最小买入价格只需要和在其之后的价格计算最大利润。

代码参考：CYangLi/leetcode/leetcode121.c

### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组，它的第i个元素是一支给定股票第i天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例:

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
     
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

提示：

    1 <= prices.length <= 3 * 10 ^ 4
    0 <= prices[i] <= 10 ^ 4

问题分析:

画个价格折线图，更有利于理解。

通过比较前后两个价格找出价格曲线的拐点，累计计算所有的价格上升的部分。每一次的峰和谷的值是不一样的，所以每次遇到峰时需要重置最小买入价格为当前位置的价格，然后寻找这个峰之后的谷。

注意，价格一直上升，和价格一直下降的情况。

代码参考：CYangLi/leetcode/leetcode122.c

### [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

示例:

```
输入: "A man, a plan, a canal: Panama"
输出: true
```

问题分析：注意要去掉空格和特殊符号的，同时还要处理大小写。

代码参考：CYangLi/leetcode/leetcode125.c