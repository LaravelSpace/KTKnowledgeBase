## LeetCode1-50题

### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。你可以按任意顺序返回答案。

提示：

    2 <= nums.length <= 103
    -109 <= nums[i] <= 109
    -109 <= target <= 109
    只会存在一个有效答案

示例：

```
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

问题分析：

这里可以把数组键值互换，把数组变成一个map。这样就可以通过遍历map，用目标值减去map的键值，得到另一个目标数的数值，然后判断这个数值是不是map的键。这里需要注意，原数组里数字重复出现多次的情况。

代码参考：PHPYangLi/app/leetcode/leetcode1.php

### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字0之外，这两个数都不会以0开头。

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

提示：

    每个链表中的节点数在范围 [1, 100] 内
    0 <= Node.val <= 9
    题目数据保证列表表示的数字不含前导零

问题分析：

因为链表是倒序的，所以直接从头开始做加法就行了，这里需要注意两个数字不一样长的情况，进位的时候需要注意3位数变4位数的情况。

代码参考：CYangLi/leetcode/leetcode2.c

### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。

示例：

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是子串的长度，"pwke" 是一个子序列，不是子串。
```

提示：

```
0 <= s.length <= 5 * 104
s 由英文字母、数字、符号和空格组成
```

问题分析：

这题可以使用滑动窗口的思路，需要左右两个指针，左右指针都从字符串头部开始移动。右指针向右侧移动，如果遇到没出现过的字符，就用一个hash表记录一下。如果右指针遇到的字符在hash表中出现过，那么就说明左边的子串中有重复的字符。这个时候移动左指针，直到找到这个字符，中间遇到的字符全部从hash表中移除。在移动指针的时候统计一个子串的最大长度，就是本题的答案。

代码参考：CYangLi/leetcode/leetcode3.c

### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串s，找到s中最长的回文子串。

示例：

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

提示：

```
1 <= s.length <= 1000
s 仅由数字和英文字母（大写和/或小写）组成
```

问题分析：

这题根据回文串的特性，采用中心扩散的方式，选中一个中心字符后，依次判断两侧的字符是否一致。这里需要注意中心字符是连续的相同的字符的情况，这种情况可以把中心连续的相同的字符看作是一个整体。

代码参考：CYangLi/leetcode/leetcode5.c

### [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)

给你一个32位的有符号整数x，返回x中每位上的数字反转后的结果。如果反转后整数超过32位的有符号整数的范围[−2^31^,2^31^−1]，就返回0。假设环境不允许存储64位整数（有符号或无符号）。

示例：

```
输入：x = 123
输出：321
```

提示：

```
-2^31 <= x <= 2^31 - 1
```

问题分析：

这题的思路在于确认有没有发生溢出，所以把符号去掉，单纯的看正数的时候。溢出一定伴随着数字的变化，所以如果保存上一次处理的结果和阶数，就可以比较下一次处理完成后，除了最后一位数字，前面数字的对应关系。最后单独讨论一下-2147483648这个数字，因为前面转换正数的时候，这个值是转换不了的。

另外一个思路，直接乘10会让数值溢出，如果不想溢出的话，换个思路，用最大值减10次，看看最大值够不够减，如果不够减那就证明乘10之后会比最大值大。

代码参考：CYangLi/leetcode/leetcode7.c

### [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

给你一个整数x，如果x是一个回文整数，返回true；否则，返回false。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121是回文，而123不是。

进阶：你能不将整数转为字符串来解决这个问题吗？

示例：

```
输入：x = 121
输出：true

输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

提示：

```
-2^31 <= x <= 2^31 - 1
```

问题分析：

这题最简单的思路就是转换成数组或者字符串然后比对。

进阶问题可以利用10的倍数直接把对应位置的数字掐头去尾算出来。比如对于12321来说，左边的1=(int)(12321/10^4^)%10^1^%10，右边的1=(int)(12321%10^1^/10^0^)；左边的2=(int)(12321/10^3^)%10^2^%10，右边的2=(int)(12321%10^2^/10^1^)；