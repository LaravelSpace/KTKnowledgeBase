## LeetCode1-50题

### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。你可以按任意顺序返回答案。

提示：

    2 <= nums.length <= 103
    -109 <= nums[i] <= 109
    -109 <= target <= 109
    只会存在一个有效答案

示例：

```
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

问题分析：这里可以把数组键值互换，把数组变成一个map。这样就可以通过遍历map，用目标值减去map的键值，得到另一个目标数的数值，然后判断这个数值是不是map的键。这里需要注意，原数组里数字重复出现多次的情况。

代码参考：PHPYangLi/app/leetcode/leetcode1.php

### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字0之外，这两个数都不会以0开头。

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

提示：

    每个链表中的节点数在范围 [1, 100] 内
    0 <= Node.val <= 9
    题目数据保证列表表示的数字不含前导零

问题分析：因为链表是倒序的，所以直接从头开始做加法就行了，这里需要注意两个数字不一样长的情况，进位的时候需要注意3位数变4位数的情况。

代码参考：CYangLi/leetcode/leetcode2.c

### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。

示例：

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是子串的长度，"pwke" 是一个子序列，不是子串。
```

提示：

```
0 <= s.length <= 5 * 104
s 由英文字母、数字、符号和空格组成
```

问题分析：这题可以使用滑动窗口的思路，需要左右两个指针，左右指针都从字符串头部开始移动。右指针向右侧移动，如果遇到没出现过的字符，就用一个hash表记录一下。如果右指针遇到的字符在hash表中出现过，那么就说明左边的子串中有重复的字符。这个时候移动左指针，直到找到这个字符，中间遇到的字符全部从hash表中移除。在移动指针的时候统计一个子串的最大长度，就是本题的答案。

代码参考：CYangLi/leetcode/leetcode3.c

### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串s，找到s中最长的回文子串。

示例：

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

提示：

```
1 <= s.length <= 1000
s 仅由数字和英文字母（大写和/或小写）组成
```

问题分析：这题根据回文串的特性，采用中心扩散的方式，选中一个中心字符后，依次判断两侧的字符是否一致。这里需要注意中心字符是连续的相同的字符的情况，这种情况可以把中心连续的相同的字符看作是一个整体。

代码参考：CYangLi/leetcode/leetcode5.c

### [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)

给你一个32位的有符号整数x，返回x中每位上的数字反转后的结果。如果反转后整数超过32位的有符号整数的范围[−2^31^,2^31^−1]，就返回0。假设环境不允许存储64位整数（有符号或无符号）。

示例：

```
输入：x = 123
输出：321
```

提示：

```
-2^31 <= x <= 2^31 - 1
```

问题分析：

这题的思路在于确认有没有发生溢出，所以把符号去掉，单纯的看正数的时候。溢出一定伴随着数字的变化，所以如果保存上一次处理的结果和阶数，就可以比较下一次处理完成后，除了最后一位数字，前面数字的对应关系。最后单独讨论一下-2147483648这个数字，因为前面转换正数的时候，这个值是转换不了的。

另外一个思路，直接乘10会让数值溢出，如果不想溢出的话，换个思路，用最大值减10次，看看最大值够不够减，如果不够减那就证明乘10之后会比最大值大。

代码参考：CYangLi/leetcode/leetcode7.c

### [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

给你一个整数x，如果x是一个回文整数，返回true；否则，返回false。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121是回文，而123不是。

进阶：你能不将整数转为字符串来解决这个问题吗？

示例：

```
输入：x = 121
输出：true

输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

提示：

```
-2^31 <= x <= 2^31 - 1
```

问题分析：

这题最简单的思路就是转换成数组或者字符串然后比对。

进阶问题可以利用10的倍数直接把对应位置的数字掐头去尾算出来。比如对于12321来说，左边的1=(int)(12321/10^4^)%10^1^%10，右边的1=(int)(12321%10^1^/10^0^)；左边的2=(int)(12321/10^3^)%10^2^%10，右边的2=(int)(12321%10^2^/10^1^)；

代码参考：CYangLi/leetcode/leetcode9.c

### [13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

罗马数字包含以下七种字符:I，V，X，L，C，D和M。I=1；V=5；X=10；L=50；C=100；D=500；M=1000；例如，罗马数字2写做II，即为两个并列的1。12写做XII，即为X+II。27写做XXVII,即为XX+V+II。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如4不写做IIII，而是IV。数字1在数字5的左边，所表示的数等于大数5减小数1得到的数值4。同样地，数字9表示为IX。这个特殊的规则只适用于以下六种情况：

    I可以放在V(5)和X(10)的左边，来表示4和9。
    X可以放在L(50)和C(100)的左边，来表示40和90。
    C可以放在D(500)和M(1000)的左边，来表示400和900。

给定一个罗马数字，将其转换成整数。输入确保在1到3999的范围内。

提示：

    1 <= s.length <= 15
    s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
    题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
    题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
    IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
    关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。

问题分析：题目描述已经非常清楚了，直接按着描述的逻辑写代码就行了，直接switch就可以。

代码参考：CYangLi/leetcode/leetcode13.c

### [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串`""`。

示例：

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

提示：

    0 <= strs.length <= 200
    0 <= strs[i].length <= 200
    strs[i] 仅由小写英文字母组成

问题分析：用第一个字符串作为参照，依次校验每一个字符串对应位置是否相同。

代码参考：CYangLi/leetcode/leetcode14.c

代码参考：PHPYangLi/leetcode/leetcode14.php

### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括'('，')'，'{'，'}'，'['，']'的字符串s ，判断字符串是否有效。有效字符串需满足：1、左括号必须用相同类型的右括号闭合；2、左括号必须以正确的顺序闭合。

示例：

```
输入：s = "()[]{}"
输出：true
```

提示：

```
1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成
```

问题分析：使用栈的思路，如果遇到 '{','[','('，就入栈，遇到 ')',']','}'，就从栈里取出最上层元素，进行匹配。如果匹配不成对，则说明存在交叉的括号。如果扫描结束，栈里还有没有匹配的括号，则说明存在落单的括号。

代码参考：CYangLi/leetcode/leetcode20.c

### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

提示：

    两个链表的节点数目范围是 [0, 50]
    -100 <= Node.val <= 100
    l1 和 l2 均按非递减顺序排列

问题分析：思路很简单了，注意空链表，还有链表不一样长的情况。

代码参考：CYangLi/leetcode/leetcode21.c

### [26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。

示例:

```
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
```

问题分析：双指针思路，慢指针用于记录结果，快指针用于遍历。

代码参考：CYangLi/leetcode/leetcode26.c

### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

给你一个数组nums和一个值val，你需要原地移除所有数值等于val的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用O(1)额外空间并原地修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例：

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

示例：

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

提示：

```
0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100
```

问题分析：双指针思路，慢指针用于记录结果，快指针用于遍历。

代码参考：CYangLi/leetcode/leetcode27.c

### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。

示例:

```
输入: [1,3,5,6], 7
输出: 4
```

问题分析：二分查找，注意边界。

代码参考：CYangLi/leetcode/leetcode35.c

### [38. 外观数列](https://leetcode-cn.com/problems/count-and-say/)

给定一个正整数n，输出外观数列的第n项。「外观数列」是一个整数序列，从数字1开始，序列中的每一项都是对前一项的描述。你可以将其视作是由递归公式定义的数字字符串序列：

    countAndSay(1) = "1"
    countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。

前五项如下：

```
1.     1
2.     11
3.     21
4.     1211
5.     111221
```

第一项是数字1
描述前一项，这个数是1即“一个1”，记作"11"
描述前一项，这个数是11即“二个1”，记作"21"
描述前一项，这个数是21即“一个2+一个1”，记作"1211"
描述前一项，这个数是1211即“一个1+一个2+二个1”，记作"111221"

要描述一个数字字符串，首先要将字符串分割为最小数量的组，每个组都由连续的最多相同字符组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

问题分析：递归，题目描述的很清楚了，注意字符串的长度几乎是倍增的，分配内存的时候需要大一点。

代码参考：CYangLi/leetcode/leetcode38.c