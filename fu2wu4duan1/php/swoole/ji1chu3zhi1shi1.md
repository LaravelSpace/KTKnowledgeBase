## 基础知识

### Swoole的进程、线程、协程之间的关系

##### 进程

进程是系统中正在运行的一个程序，程序一旦运行就是进程。进程可以看成程序执行的一个实例。

一个进程无法访问另一个进程的变量和数据结构，如果想让一个进程访问另一个进程的资源，需要使用进程间通信，比如管道，文件，套接字等。

对CPU多核的利用，依赖于Swoole引擎的多进程机制。

##### 线程

线程属于进程，是程序的执行者。一个进程至少包含一个主线程，也可以有更多的子线程，每个线程使用其所属进程的栈空间。

线程是进程的一个实体，是进程的一条执行路径。同一进程内的多个线程会共享部分状态，多个线程可以读写同一块内存。

##### 协程

协程属于线程，协程是在线程里执行的。协程是程序内部的一定调度机制，是轻量级线程，协程的创建、切换、挂起、销毁全部为内存操作，消耗是非常低的。

Swoole的协程在底层实现上是单线程的，因此同一时间只有一个协程在工作，协程的执行是串行的。这与线程不同，多个线程会被操作系统调度到多个CPU并行执行。一个协程正在运行时，其他协程会停止工作。当前协程执行阻塞IO操作时会挂起，底层调度器会进入事件循环。当有IO完成事件时，底层调度器恢复事件对应的协程的执行。

##### Master进程

Master进程是一个多线程进程。主进程内有多个Reactor线程，基于epoll/kqueue进行网络事件轮询。收到数据后转发到Worker进程去处理。

##### Reactor线程

Reactor线程是在Master进程中创建的线程。负责维护客户端TCP连接、处理网络IO、处理协议、收发数据。将TCP客户端发来的数据缓冲、拼接、拆分成完整的一个请求数据包。不执行任何PHP代码。

##### Worker进程

Worker以多进程的方式运行，可以是异步非阻塞模式，也可以是同步阻塞模式。对收到的数据进行处理，包括协议解析和响应请求。接受由Reactor线程投递的请求数据包，并执行PHP回调函数处理数据。生成响应数据并发给Reactor线程，由Reactor线程发送给TCP客户端。

如果未设置Server->worker_num，底层会启动与CPU数量一致的Worker进程。多个Worker进程就会绑定到多个CPU，并行执行。

当Worker进程内发生致命错误或者人工执行exit()时，进程会自动退出。Master进程会重新启动一个新的Worker进程来继续处理请求。

每个Worker都是一个单独的协程调度器，不同进程之间是完全隔离的。在单个Worker进程内会多创建AIO线程和CPU中断线程。

##### TaskWorker进程

TaskWorker以多进程的方式运行，完全是同步阻塞模式。接受由Worker进程通过Swoole\Server->task/taskwait/taskCo/taskWaitMulti()方法投递的任务。处理任务，并将结果数据返回（使用Swoole\Server->finish()）给Worker进程。

##### Manager进程

负责创建/回收Worker/Task进程。对所有Worker进程进行管理，Worker进程生命周期结束或者发生异常时自动回收，并创建新的Worker进程。

它们之间的关系可以理解为Reactor就是nginx，Worker就是PHP-FPM。Reactor线程异步并行地处理网络请求，然后再转发给Worker进程中去处理。Reactor和Worker间通过unixSocket进行通信。

在PHP-FPM的应用中，经常会将一个任务异步投递到Redis等队列中，并在后台启动一些PHP进程异步地处理这些任务。Swoole的Reactor、Worker、TaskWorker之间可以紧密的结合起来，提供更高级的使用方式。Swoole提供的TaskWorker是一套更完整的方案，将任务的投递、队列、PHP任务处理进程管理合为一体。通过底层提供的API可以非常简单地实现异步任务的处理。另外TaskWorker还可以在任务执行完成后，再返回一个结果反馈到Worker。

---

| 参考来源                                                     |
| ------------------------------------------------------------ |
| [关于协程调度和worker进程的问题](https://wenda.swoole.com/detail/107677) |