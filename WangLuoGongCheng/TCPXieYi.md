```json
{
  "updated_at": "2020-07-20",
  "updated_by": "KelipuTe",
  "tags": "数据结构,Data Structure"
}
```

---

## TCP协议

### TCP协议简介

互联网由一整套协议构成。TCP只是其中的一层，有着自己的分工。TCP是以太网协议和IP协议的上层协议，也是应用层协议的下层协议。

最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部（局域网）的点对点通信。但是，以太网协议不能解决多个局域网如何互通，这由IP协议解决，IP协议可以连接多个局域网。

IP协议定义了一套自己的地址规则，称为IP地址。它实现了路由功能，允许某个局域网的A主机，向另一个局域网的B主机发送消息。路由器就是基于IP协议，局域网之间要靠路由器连接。路由的原理很简单，路由器背后都有很多网口，要接入多根网线。路由器内部有一张路由表，路由表注明了不同IP目的地的数据包，要发送到哪一个网口（interface）。比如，规定了A段IP地址走出口一，B段地址走出口二，......通过这套指路牌，实现了数据包的转发。

但是IP协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠TCP协议。简单说，TCP协议的作用是，保证数据通信的完整性和可靠性，防止丢包。

### TCP与HTTP

收到TCP数据包以后，组装还原是操作系统完成的。应用程序不会直接处理TCP数据包。操作系统不会去处理 TCP数据包里面的数据。一旦组装好TCP数据包，就把它们转交给应用程序。

TCP数据包里面有一个端口（port）参数，就是用来指定转交给监听该端口的应用程序。系统根据TCP数据包里面的端口，将组装好的数据转交给相应的应用程序。比如，21端口是FTP服务器，25端口是SMTP服务，80端口是Web服务器。

对于应用程序来说，不用关心数据通信的细节。除非线路异常，收到的总是完整的数据。应用程序需要的数据放在TCP数据包里面，有自己的格式（比如HTTP协议）。

TCP不存在连接的概念，只存在请求和响应，请求和响应都是数据包。它们之间都是经过由TCP创建的一个客户端发起，服务器接收的类似连接的通道。这个连接可以一直保持，HTTP请求是在这个连接的基础上发送的。在一个TCP连接上是可以发送多个HTTP请求的，不同的版本这个模式不一样。

- HTTP/1.0中这个TCP连接是在HTTP请求创建的时候同步创建的，HTTP请求发送到服务器，服务器响应了之后，这个TCP连接就关闭了。
- HTTP/1.1中这个连接一直保持，一个请求传输完之后，另一个请求可以接着传输。在创建一个TCP连接的过程中需要三次握手的消耗，三次握手代表有三次网络传输。如果TCP连接保持，第二个请求发送就没有这三次握手的消耗。
- HTTP/2中同一个TCP连接里还可以并发地传输HTTP请求。

### TCP报文格式

![](E:\Workspace\KTKnowledgeBase\Image\WangLuoGongCheng\TCPXieYi_img01.png)

首先我们先来看一下TCP报文的格式，整体上TCP报文属于IP报文的一部分。TCP数据包在IP数据包的负载里面。IP数据包又在以太网数据包里面。

![](E:\Workspace\KTKnowledgeBase\Image\WangLuoGongCheng\TCPXieYi_img02.jpeg)



详细的TCP报文格式看下面这张图。

![](E:\Workspace\KTKnowledgeBase\Image\WangLuoGongCheng\TCPXieYi_img03.png)

TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。

序号（4字节=32位）用来标识TCP发端向TCP收端发送的数据字节流。

确认序号（4字节=32位）：SYN报文，ACK标志为0，没有确认序号。TCP协议规定，只有ACK=1时确认序号才有效，也规定连接建立后所有发送的报文的ACK必须为1。一旦连接建立，该值将始终发送（同ACK标志）。

标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN。

- URG：长1位，表示紧急指针字段有效。
- ACK：长1位，置位表示确认号字段有效；TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。
- PSH：长1位，表示当前报文需要请求推（push）操作。
- RST：长1位，置位表示复位TCP连接。
- SYN：长1位，在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1。因此，SYN置1就表示这是一个连接请求或连接接受报文。
- FIN：长1位，用于释放TCP连接时标识发送方比特流结束。用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

窗口大小：长度为16位，2个字节。

校验和：长度为16位，2个字节。

紧急指针：长度为16位，2个字节。

以上是TCP包头必须要有的字段，也称固有字段，长度为20个字节。

### 三次握手（Three-Way Handshake）

TCP通过三次握手保证传输任务的可靠。TCP三次握手就好比客户端与服务器看见了对方，但是不能100%确认，所以要通过握手的方式相互确定对方。三次握手即TCP连接的建立。这个连接必须是一方主动打开，另一方被动打开的。以下为客户端主动发起连接的图解：

![](E:\Workspace\KTKnowledgeBase\Image\WangLuoGongCheng\TCPXieYi_img04.jpeg)

握手之前主动打开连接的客户端结束CLOSED阶段，被动打开的服务器也结束CLOSED阶段，并进入LISTEN阶段。随后开始三次握手：

1、首先客户端向服务器发出请求连接，即SYN=1，ACK=0。TCP规定SYN=1时不能携带数据，但要消耗一个序号，因此声明自己的序号是seq=x（x一般为1）。随后客户端进入SYN-SENT阶段。

2、服务器接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文进行回复确认，即SYN=1，ACK=1，seq=y，ack=x+1。标志位为SYN和ACK，表示确认客户端的报文seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接。确认号为ack=x+1，表示收到客户端的序号seq并将其值加1作为自己确认号ack的值。随后服务器进入SYN-RCVD阶段。

3、客户端接收到来自服务器的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段，并返回最后一段TCP报文。这次ACK=1，seq=x+1，ack=y+1，不用SYN了。标志位为ACK，表示确认收到服务器同意连接的信号。序号为seq=x+1，表示收到服务器的确认号ack，并将其值作为自己的序号值。确认号为ack=y+1，表示收到服务器序号seq，并将其值加1作为自己的确认号ack的值。随后客户端进入ESTABLISHED阶段。服务器收到来自客户端的确认收到服务器数据的TCP报文之后，明确了从服务器到客户端的数据传输是正常的，结束SYN-SENT阶段，进入ESTABLISHED阶段。

这里别把AKC标志位和ack确认号搞混了，这两个东西不一样。

seq是序列号，这是为了连接以后传送数据用的，ack是对收到的数据包的确认，值是等待接收的数据包的序列号。seq是数据包本身的序列号，ack是期望对方继续发送的那个数据包的序列号。

- 第一次，客户端随机选取一个序列号作为自己的初始序号发送给服务器；
- 第二次，服务器使用ack对客户端的数据包进行确认，因为已经收到了序列号为x的数据包，准备接收序列号为x+1的包，所以ack=x+1，同时服务器告诉客户端自己的初始序列号，就是seq=y；
- 第三条，客户端告诉服务器收到了服务器的确认消息并准备建立连接，客户端自己此条消息的序列号是x+1，所以seq=x+1，而ack=y+1是表示客户端正准备接收服务器序列号为y+1的数据包。

在客户端与服务器传输的TCP报文中，双方的确认号ack和序号seq的值，都是在彼此ack和seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性。一旦出现某一方发出的TCP报文丢失，便无法继续握手，以此确保了三次握手的顺利完成。

#### 三次握手的作用

三次握手的作用主要是保证客户端到服务器之间建立了有效的连接。一是防止服务端无用的连接增加服务器开销。二是防止已失效的连接的报文突然又传送到了服务端，从而产生错误。

网络传输是有延时的。在传输的过程中，客户端发起了SYN=1创建连接的请求。如果服务器返回给客户端的包含SYN、ACK和seq等内容的数据包因为网络传输的原因丢失了，丢失之后客户端就没有接收到服务器返回的数据包。

可能客户端设置了一个超时时间，时间到了就关闭了连接创建的请求，再重新发出创建连接的请求，而服务器是不知道的。如果没有第三次握手告诉服务器客户端收到了到服务器传输的数据的话，服务器是不知道客户端有没有接收到服务器返回的信息的。

这样没有给服务器一个创建还是关闭连接端口的请求，服务器的端口就一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。那么服务器上没有接收到请求数据的上一个端口就一直开着，这样的端口多了，就会造成服务器开销的严重浪费。所以我们需要第三次握手来确认这个过程，让客户端和服务器能够及时地察觉到因为网络等一些问题导致的连接创建失败，这样服务器的端口就可以关闭了，不用一直等待。

### 数据传输

TCP数据传输的过程需要对方响应确认就是返回ack。如果没收到ack，这个时候有两种情况，一个是请求就没到，第二个是响应没回来，这两种情况下都会重新传一次，这就是TCP重传。一串连续的请求的响应可以不用一一回复，回复一次就可以，这就是批量ack。但是一串连续的请求也不能太多，太多了对方来不及处理，所以二者需要协商好速率，这就是TCP窗口大小。

### 慢启动和ACK

服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。最理想的状态是，在线路允许的情况下，达到最高速率。

但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。TCP协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。

默认情况下，接收方每收到两个TCP数据包，就要发送一个确认消息。确认的英语是acknowledgement，所以这个确认消息就简称ACK。ACK携带两个信息：1、期待要收到下一个数据包的编号；2、接收方的接收窗口的剩余容量。发送方有了这两个信息，再加上自己已经发出的数据包的最新编号，就会推测出接收方大概的接收速度，从而降低或增加发送速率。这被称为发送窗口，这个窗口的大小是可变的。

注意，由于TCP通信是双向的，所以双方都需要发送ACK。两方的窗口大小，很可能是不一样的。

### 数据包的遗失处理

TCP协议可以保证数据通信的完整性。每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么ACK的编号就不会发生变化。针对数据包丢失的情况，会用重传机制解决。常见的重传机制有下面四种：超时重传；快速重传；SACK；D-SACK。

#### 超时重转

重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的ACK确认应答报文，就会重发该数据，也就是我们常说的超时重传。TCP会在以下两种情况发生超时重传：数据包丢失；确认应答丢失。

这里涉及到超时时间的设置，但是首先先了解一下什么是RTT（Round-Trip Time 往返时延）。RTT就是数据从网络一端传送到另一端所需的时间，也就是包的往返时间。

![](E:\Workspace\KTKnowledgeBase\Image\WangLuoGongCheng\TCPXieYi_img07.png)

超时重传时间是以RTO （Retransmission Timeout 超时重传时间）表示。超时重传时间不能过短也不能过长。当超时时间RTO较大时，重发就慢，丢了老半天才重发，没有效率，性能差。当超时时间RTO较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。所以超时重传时间RTO的值应该略大于报文往返RTT的值。

![](E:\Workspace\KTKnowledgeBase\Image\WangLuoGongCheng\TCPXieYi_img08.png)

因为我们的网络也是时常变化的，所以超时重传时间RTO的值应该是一个动态变化的值。如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP的策略是超时间隔加倍。

也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。

#### 快速重传

TCP还有另外一种快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以数据驱动重传。

现在收到了4号包，但是没有收到5号包。ACK就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮ACK会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么ACK里面的编号不会变化，总是显示5号包。这会导致大量重复内容的ACK。

如果发送方发现收到三个连续的重复ACK，或者超时了还没有收到任何ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP保证了不会有数据包丢失。如下图，HostB没有收到100号数据包，会连续发出相同的ACK，触发HostA重发100号数据包。

![](E:\Workspace\KTKnowledgeBase\Image\WangLuoGongCheng\TCPXieYi_img06.png)

### 四次挥手（Four-Way Wavehand）

所谓的四次挥手即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放。中断连接端可以是客户端，也可以是服务器。以下为客户端主动发起释放连接的图解：

![](E:\Workspace\KTKnowledgeBase\Image\WangLuoGongCheng\TCPXieYi_img05.jpeg)

挥手之前主动释放连接的客户端结束ESTABLISHED阶段。随后开始四次挥手：

1、首先客户端想要释放连接，向服务器发送一段TCP报文，FIN=1，ack=u。标记位为FIN，表示请求释放连接。随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器方向上发送数据，但是客户端仍然能接收从服务器传输过来的数据。需要注意的是吗，这里不发送的是正常连接时传输的数据，而不是一切数据，客户端仍然能发送ACK确认报文。

2、服务器接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，ACK=1，seq=v，ack=u+1。标记位为ACK，表示接收到客户端发送的释放连接的请求。随后服务器开始准备释放服务器到客户端方向上的连接。客户端收到从服务器发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段。

> 前两次挥手既让服务器知道了客户端想要释放连接，也让客户端知道了服务器了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器方向上的连接了。

3、服务器自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器到客户端方向上的连接准备，再次向客户端发出一段TCP报文，FIN=1，ACK=1，seq=w，ack=u+1。标记位为FIN和ACK，表示已经准备好释放连接了。注意一下这里的ACK并不是确认收到服务器报文的确认报文。确认号为ack=u+1，表示是在收到客户端报文的基础上，将其序号seq值加1作为本段报文确认号ack的值。随后服务器结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器到客户端的方向上发送数据，但是服务器仍然能够接收从客户端传输过来的数据。

4、客户端收到从服务器发出的TCP报文，确认了服务器已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器发送一段报文，ACK=1，seq=u+1，ack=w+1。标记位为ACK，表示“接收到服务器准备好释放连接的信号”。序号为seq=u+1，表示是在收到了服务器报文的基础上，将其确认号ack值作为本段报文序号的值。确认号为ack=w+1，表示是在收到了服务器报文的基础上，将其序号seq值作为本段报文确认号的值。随后客户端开始在TIME-WAIT阶段等待2MSL。

服务器收到从客户端发出的TCP报文之后结束LAST-ACK阶段，进入CLOSED阶段。由此正式确认关闭服务器到客户端方向上的连接。客户端等待完2MSL之后，结束TIME-WAIT阶段，进入CLOSED阶段，由此完成四次挥手。

> 后两次挥手既让客户端知道了服务器准备好释放连接了，也让服务器知道了客户端了解了自己准备好释放连接了。于是，可以确认关闭服务器到客户端方向上的连接了，由此完成四次挥手。

#### 为什么挥手是四次

TCP建立连接时之所以只需要三次握手，是因为在第二次"握手"过程中，服务器发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器同意建立连接；ACK是确认报文，表示告诉客户端，服务器收到了它的请求报文。即SYN建立连接报文与ACK确认接收报文是在同一次"握手"当中传输的，所以三次握手不多也不少，正好让双方明确彼此信息互通。

TCP释放连接时之所以需要四次挥手,是因为ACK确认接收报文和FIN释放连接报文是分别由第二次和第三次挥手传输的。建立连接时，被动方服务器结束CLOSED阶段进入握手阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。

#### 为什么客户端在TIME-WAIT阶段要等2MSL

为的是确认服务器是否收到客户端发出的ACK确认报文。

当客户端发出最后的ACK确认报文时，并不能确定服务器能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime，即一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。当服务器在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文。

如果客户端在2MSL内，再次收到了来自服务器的FIN报文，说明服务器由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器发出ACK确认报文，计时器重置，重新开始2MSL的计时。否则客户端在2MSL内没有再次收到来自服务器的FIN报文，说明服务器正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成四次挥手。

---

## 参考来源

[跟着动画来学习TCP三次握手和四次挥手](https://juejin.im/post/5b29d2c4e51d4558b80b1d8c)

[详解 TCP 连接的“三次握手”与“四次挥手”](https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc)

[TCP报文格式](https://www.cnblogs.com/shineyoung/p/10656914.html)

[TCP 协议简介](http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html)

