## TCP拥塞控制

这里要和流量控制区分一下，**流量控制的目的是避免发送方的数据填满接收方的缓存**，但是并不知道网络的中发生了什么。一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大。

所以，TCP不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP会自我牺牲，降低发送的数据量。于是，就有了拥塞控制，**拥塞控制的目的就是避免发送方的数据填满整个网络**。为了在发送方调节所要发送数据的量，定义了一个叫做**拥塞窗口**的概念。

拥塞窗口（cwnd）是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。我们在前面提到过发送窗口（swnd）和接收窗口（rwnd）是约等于的关系，那么由于入了拥塞窗口的概念后，此时发送窗口的值是 `swnd=min(cwnd, rwnd)`，也就是拥塞窗口和接收窗口中的最小值。

拥塞窗口cwnd变化的规则：只要网络中没有出现拥塞，cwnd就会增大；一但网络中出现了拥塞，cwnd就减少。一般只要发送方没有在规定时间内接收到ACK应答报文，也就是发生了超时重传，就会认为网络出现了用拥塞。

拥塞控制主要有四个方案：慢启动；拥塞避免；拥塞发生；快速恢复。

### 慢启动

服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。最理想的状态是，在线路允许的情况下，达到最高速率。

但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。TCP协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。

慢启动的算法记住一个规则就行：**当发送方每收到一个ACK，拥塞窗口cwnd的大小就会加1**。注意，发包的个数是**指数性的增长**。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img24.png)

慢启动会受到慢启动门限ssthresh（slow start threshold）状态变量的控制。当 $cwnd<ssthresh$ 时，使用慢启动算法。当 $cwnd \geq ssthresh$ 时，就会使用拥塞避免算法。

### 拥塞避免算法

一般来说ssthresh的大小是65535字节。进入拥塞避免算法后，它的规则是：**当发送方每收到一个ACK，拥塞窗口cwnd的大小就会增加1/cwnd**。拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img25.png)

网络慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。当触发了重传机制，也就进入了拥塞发生算法。重传机制主要有两种：超时重传；快速重传。这两种使用的拥塞发送算法是不同的。

### 拥塞发生

当发生了超时重传，则就会使用拥塞发生算法。这个时候，ssthresh设为cwnd/2；cwnd重置为1。接着，就重新开始慢启动，慢启动是会突然减少数据流的。这种方式反应很强烈，会造成网络卡顿。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img26.png)



### 快速恢复

快速重传和快速恢复算法一般同时使用。当发生快速重传时，TCP认为这种情况不严重，因为大部分数据包没丢，只丢了一小部分。这个时候，cwnd设为cwnd/2 ，也就是设置为原来的一半；ssthresh设为cwnd；然后进入快速恢复算法。

快速恢复算法是认为，还能收到3个重复ACK说明网络也不那么糟糕，所以没有必要像RTO超时时反应那么强烈。快速恢复算法如下：

- 拥塞窗口cwnd设为ssthresh+3（3的意思是确认有3个数据包被收到了）；
- 重传丢失的数据包；
- 如果再收到重复的ACK，那么cwnd增加1；
- 如果收到新数据的ACK后，把cwnd设置为第一步中的ssthresh的值，原因是该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

