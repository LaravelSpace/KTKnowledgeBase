```json
{
  "updated_at": "2020-08-02",
  "updated_by": "KelipuTe",
  "tags": "网络工程,Network Engineering,HTTP"
}
```

---

## HTTP与HTTPS

### HTTP是怎么工作的

HTTP是属于应用层的协议，它是基于TCP/IP的，所以它只是规定一些要传输的内容，以及头部信息，然后通过TCP协议进行传输，依靠IP协议进行寻址。客户端发出请求，服务端进行响应，就是这么简单。

在整个过程中，没有任何加密的东西，所以它是不安全的，中间人可以进行拦截，获取传输和响应的数据，造成数据泄露。因为数据是明文传输的，我们能想到最简单的提高安全性的方法就是在传输前对数据进行加密。

### 如何实现加密

首先最先想到的肯定是对称加密。加密和解密用同一个秘钥的加密方式叫做对称加密。因为加密解密使用的是同一个秘钥，所以双方都必须知道这个秘钥是什么。在网络环境下，这显然不合理，用为如果所有客户端都有秘钥，只要有一个客户端的秘钥泄露，那么整个环境的加密就不安全了。而且就算所有的客户端都能保证安全，秘钥传输的过程也是不安全的。所以对称加密肯定是不行的，这个时候就需要使用非对称加密了。

非对称加密会有一对秘钥：公钥和私钥。公钥加密的内容，只有私钥可以解开，私钥加密的内容，所有的公钥都可以解开。私钥只保存在服务器端，公钥可以发送给所有的客户端。在传输公钥的过程中，肯定也会有被中间人获取的风险，但在目前的情况下，至少可以保证客户端通过公钥加密的内容，中间人是无法破解的，因为私钥只保存在服务器端，只有私钥可以破解公钥加密的内容。

### MITM

MITM：Man-in-the-MiddleAttack，中间人攻击，是一种网络攻击方式，攻击的流程如下图。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\HTTPXueYi_img01.webp)

这个时候，客户端拿到的公钥就是假的。公钥被掉包，是因为客户端无法分辨传回公钥的到底是中间人，还是服务器，这也是密码学中的身份验证问题。在HTTPS中，使用证书+数字签名来解决这个问题。

### 第三方认证

MD5算法（Message-Digest Algorithm 5）又称信息-摘要算法5，大家应该很熟悉了。MD5本身并不是一个加密算法，因为数据经过MD5之后，是无法通过解密的手段得到原始信息的。这里为了便于理解HTTPS的工作流程，我们假设MD5是一个加密手段。将网站的信息通过MD5加密后，交给第三方机构，通过第三方机构的私钥再次进行加密，生成数字签名。最后生成一个数字证书，数字证书=网站信息+数字签名。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\HTTPXueYi_img02.webp)

假如中间人拦截后把服务器的公钥替换为自己的公钥，因为数字签名的存在，会导致客户端验证签名不匹配，这样就防止了中间人替换公钥的问题。浏览器安装后会内置一些权威第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等，验证签名的时候直接就从本地拿到相应第三方机构的公钥，对私钥加密后的数字签名进行解密得到真正的签名，然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\HTTPXueYi_img03.jpg)

数字签名的存在还可以防止中间人使用第三方认证伪造数字证书。流程和MITM很像，都是使用自己的信息替换原有的信息。这个和上文的情况一样，客户端仍然可以解密，并且无法判断这是服务器的还是中间人的。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\HTTPXueYi_img04.webp)

### HTTPS

HTTPS=HTTP+TLS/SSL，它介于TCP协议和HTTP协议之间。使用SSL/TLS协议进行加密传输，让客户端安全的拿到服务器的公钥。在拿到服务器的公钥之后，客户端会随机生成一个对称加密的秘钥，使用服务器公钥加密，传输给服务端，此后的数据就通过这个随机生成的对称秘钥进行加密/解密，服务器也通过该对称秘钥进行解密/加密。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\HTTPXueYi_img05.webp)