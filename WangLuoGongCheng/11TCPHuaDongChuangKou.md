## TCP滑动窗口

### 滑动窗口

TCP是每发送一个数据，都要进行一次确认应答，当上一个数据包收到了应答了再发送下一个。缺点是效率比较低，有点像面对面聊天，你一句我一句。如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。所以，这样的传输方式有一个缺点：**数据包的往返时间越长，通信的效率就越低**。

为解决这个问题，TCP引入了窗口这个概念，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。这样即使在往返时间较长的情况下，它也不会降低网络通信的效率。窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

假设窗口大小为3个TCP段，那么发送方就可以连续发送3个TCP段，并且中途若有ACK丢失，可以通过下一个确认应答进行确认。如下图：

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img12.png)

图中的ACK600确认应答报文丢失，也没关系，因为可以通话下一个确认应答进行确认，只要发送方收到了ACK700确认应答，就意味着700之前的所有数据接收方都收到了。这个模式就叫**累计确认**或者**累计应答**。

TCP头里有一个字段叫Window，也就是窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。所以，**通常窗口的大小是由接收方的决定的**。发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

#### 发送方的滑动窗口

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img13.png)

- \#1是已发送并收到ACK确认的数据：1~31字节。
- \#2是已发送但未收到ACK确认的数据：32~45字节。
- \#3是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节。
- \#4是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img14.png)

当发送方把数据全部都发送出去后，可用窗口的大小就为0了，表明可用窗口耗尽，在没收到ACK确认之前是无法继续发送数据了。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img15.png)

当收到之前发送的数据32\~36字节的ACK确认应答后，如果发送窗口的大小没有变化，则滑动窗口往右边移动5个字节，因为有5个字节的数据被应答确认，接下来52\~56字节又变成了可用窗口，那么后续也就可以发送52\~56这5个字节的数据了。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img16.png)

TCP滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。

- **SND.WND**：表示发送窗口的大小（大小是由接收方指定的）。
- **SND.UNA**：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是\#2的第一个字节。
- **SND.NXT**：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是\#3的第一个字节。
- 指向\#4的第一个字节是个相对指针，它需要SND.UNA指针加上SND.WND大小的偏移量，就可以指向#4的第一个字节了。

最后可用窗口大小的计算就可以是：$SND.WND-(SND.NXT-SND.UNA)$。

#### 接收方的滑动窗口

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img17.png)

- \#1+\#2是已成功接收并确认的数据（等待应用进程读取）。
- \#3是未收到数据但可以接收的数据。
- \#4未收到数据并不可以接收的数据。

其中三个接收部分，使用两个指针进行划分：

- **RCV.WND**：表示接收窗口的大小，它会通告给发送方。
- **RCV.NXT**：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是\#3的第一个字节。
- 指向\#4的第一个字节是个相对指针，它需要RCV.NXT指针加上RCV.WND大小的偏移量，就可以指向#4的第一个字节了。

滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过TCP报文中的Windows字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是**约等于**的关系。

### 流量控制

发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。为了解决这种现象发生，TCP提供一种机制可以让发送方根据接收方的实际接收能力控制发送的数据量，这就是所谓的流量控制。

假设以下场景：客户端是接收方，服务端是发送方；假设接收窗口和发送窗口相同，都为200；假设两个设备在整个传输过程中都保持相同的窗口大小，不受外界影响。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img18.png)

上图的过程：

- 客户端向服务端发送请求数据报文。这里要说明下，本次例子是把服务端作为发送方，所以没有画出服务端的接收窗口。
- 服务端收到请求报文后，发送确认报文和80字节的数据，于是可用窗口Usable减少为120字节，同时SND.NXT指针也向右偏移80字节后，指向321，这意味着下次发送数据的时候，序列号是321。
- 客户端收到80字节数据后，于是接收窗口往右移动80字节，RCV.NXT也就指向321，这意味着客户端期望的下一个报文的序列号是321，接着发送确认报文给服务端。
- 服务端再次发送了120字节数据，于是可用窗口耗尽为0，服务端无法在继续发送数据。
- 客户端收到120字节的数据后，于是接收窗口往右移动120字节，RCV.NXT也就指向441，接着发送确认报文给服务端。
- 服务端收到对80字节数据的确认报文后，SND.UNA指针往右偏移后指向321，于是可用窗口Usable增大到80。
- 服务端收到对120字节数据的确认报文后，SND.UNA指针往右偏移后指向441，于是可用窗口Usable增大到200。
- 服务端可以继续发送了，于是发送了160字节的数据后，SND.NXT指向601，于是可用窗口Usable减少到40。
- 客户端收到160字节后，接收窗口往右移动了160字节，RCV.NXT也就是指向了601，接着发送确认报文给服务端。
- 服务端收到对160字节数据的确认报文后，发送窗口往右移动了160字节，于是SND.UNA指针偏移了160后指向601，可用窗口Usable也就增大至了200。

前面的流量控制例子，我们假定了发送窗口和接收窗口是不变的，但是实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会被操作系统调整。当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。

#### 应用程序没有及时读取缓存

考虑以下场景：客户端作为发送方，服务端作为接收方，发送窗口和接收窗口初始大小为360；服务端非常的繁忙，当收到客户端的数据时，应用层不能及时读取数据。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img19.png)

上图的过程：

- 客户端发送140字节数据后，可用窗口变为220（360-140）。
- 服务端收到140字节数据，但是服务端非常繁忙，应用进程只读取了40个字节，还有100字节占用着缓冲区，于是接收窗口收缩到了260（360-100），最后发送确认信息时，将窗口大小通过给客户端。
- 客户端收到确认和窗口通告报文后，发送窗口减少为260。
- 客户端发送180字节数据，此时可用窗口减少到80。
- 服务端收到180字节数据，但是应用程序没有读取任何数据，这180字节直接就留在了缓冲区，于是接收窗口收缩到了80（260-180），并在发送确认信息时，通过窗口大小给客户端。
- 客户端收到确认和窗口通告报文后，发送窗口减少为80。
- 客户端发送80字节数据后，可用窗口耗尽。
- 服务端收到80字节数据，但是应用程序依然没有读取任何数据，这80字节留在了缓冲区，于是接收窗口收缩到了0，并在发送确认信息时，通过窗口大小给客户端。
- 客户端收到确认和窗口通告报文后，发送窗口减少为0。

最后窗口收缩为0了，也就是发生了窗口关闭，这个时候双方的交互就会停下来。

#### 服务端系统资源非常紧张

当服务端系统资源非常紧张的时候，操心系统可能会直接减少了接收缓冲区大小，这时应用程序又无法及时读取缓存数据，那么这时候就有严重的事情发生了，会出现数据包丢失的现象。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img20.png)

上图的过程：

- 客户端发送140字节的数据，于是可用窗口减少到了220。
- 服务端因为现在非常的繁忙，操作系统于是就把接收缓存减少了120字节，当收到140字节数据后，又因为应用程序没有读取任何数据，所以140字节留在了缓冲区中，于是接收窗口大小从360收缩成了100，最后发送确认信息时，通告窗口大小给对方。
- 此时客户端因为还没有收到服务端的通告窗口报文，所以不知道此时接收窗口收缩成了100，客户端只会看自己的可用窗口还有220，所以客户端就发送了180字节数据，于是可用窗口减少到40。
- 服务端收到了180字节数据时，发现数据大小超过了接收窗口的大小，于是就把数据包丢失了。
- 客户端收到第2步时，服务端发送的确认报文和通告窗口报文，尝试减少发送窗口到100，把窗口的右端向左收缩了80，此时可用窗口的大小就会出现诡异的负值。

所以，如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。为了防止这种情况发生，TCP规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间在减少缓存，这样就可以避免了丢包情况。

### 窗口关闭

上文介绍了流量控制会导致窗口大小为0的情况，这就是窗口关闭。如果窗口大小为0，就会阻止发送方给接收方传递数据，直到窗口变为非0为止。但是，接收方向发送方通告窗口大小时，是通过ACK报文来通告的。如果这个通告窗口的ACK报文在网络中丢失了，那麻烦就大了。这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不不采取措施，这种相互等待的过程，会造成了死锁的现象。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img21.png)

为了解决这个问题，TCP为每个连接设有一个持续定时器，只要TCP连接一方收到对方的0窗口通知，就启动持续计时器。如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。如果接收窗口仍然为0，那么收到这个报文的一方就会重新启动持续计时器。如果接收窗口不是0，那么死锁的局面就可以被打破了。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img22.png)

窗口探查探测的次数一般为3此次，每次次大约30-60秒（不同的实现可能会不一样）。如果3次过后接收窗口还是0的话，有的TCP实现就会发RST报文来中断连接。

### 糊涂窗口综合征

如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。我们的TCP+IP头有40个字节，为了传输那几个字节的数据，要达上这么大的开销，这太不经济了。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img23.png)

上面这个图，描述了一个糊涂窗口综合征产生的过程。可以看到，窗口不断在减小，发送的数据也在不断变小。因此糊涂窗口综合征产生的原因就是：接收方通告小窗口同时发送方可以发送小数据。所以解决方案也就有了：让接收方不通告小窗口给发送方或者不让发送方发送小数据。

让接收方不通告小窗口的策略如下：当窗口大小小于 `min(MSS,缓存空间/2)` ，也就是小于MSS与二分之一缓存大小中的最小值时，就会向发送方通告窗口为0，也就阻止了发送方再发数据过来。等到接收方处理了一些数据后，窗口大小>=MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。

让发送方避免发送小数据的策略如下：使用Nagle算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：1、要等到窗口大小>=MSS或是数据大小>=MSS。2、收到之前发送数据的ack回包。只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件。另外，Nagle算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet或ssh这样的交互性比较强的程序，则需要关闭Nagle算法。