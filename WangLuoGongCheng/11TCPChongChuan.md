## TCP重传

### 数据包的遗失处理

TCP协议可以保证数据通信的完整性。每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么ACK的编号就不会发生变化。针对数据包丢失的情况，会用重传机制解决。常见的重传机制有下面四种：超时重传；快速重传；SACK；D-SACK。

### 超时重转

重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的ACK确认应答报文，就会重发该数据，也就是我们常说的超时重传。TCP会在以下两种情况发生超时重传：数据包丢失；确认应答丢失。

这里涉及到超时时间的设置，但是首先先了解一下什么是RTT（Round-Trip Time 往返时延）。RTT就是数据从网络一端传送到另一端所需的时间，也就是包的往返时间。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img07.png)

超时重传时间是以RTO （Retransmission Timeout 超时重传时间）表示。超时重传时间不能过短也不能过长。当超时时间RTO较大时，重发就慢，丢了老半天才重发，没有效率，性能差。当超时时间RTO较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。所以超时重传时间RTO的值应该略大于报文往返RTT的值。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img08.png)

因为我们的网络也是时常变化的，所以超时重传时间RTO的值应该是一个动态变化的值。如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP的策略是超时间隔加倍。也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。

### 快速重传

TCP还有另外一种快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以数据驱动重传。

现在收到了4号包，但是没有收到5号包。ACK就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮ACK会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么ACK里面的编号不会变化，总是显示5号包。这会导致大量重复内容的ACK。

快速重传的工作方式是当收到三个相同的ACK 报文时，会在定时器过期之前，重传丢失的报文段。如果发送方发现收到三个连续的重复ACK，或者超时了还没有收到任何ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP保证了不会有数据包丢失。如下图，HostB没有收到100号数据包，会连续发出相同的ACK，触发HostA重发100号数据包。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img06.png)

快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。比如对于上面的例子，是重传seq100呢？还是重传seq100、seq120、seq135、seq141呢？因为发送端并不清楚这连续的三个ack100是谁传回来的。根据TCP不同的实现，以上两种情况都是有可能的。

为了解决不知道该重传哪些TCP报文，于是就有SACK方法。

### SACK方法

SACK（ Selective Acknowledgment 选择性确认），**如果要支持SACK，必须双方都要支持**。

这种方式需要在TCP头部**选项**字段里加一个SACK的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。

如下图，发送方收到了三次同样的ACK确认报文，于是就会触发快速重发机制，通过SACK信息发现只有 200\~299 这段数据丢失，则重发时，就只选择了这个TCP段进行重复。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img09.png)

### Duplicate SACK

Duplicate SACK又称D-SACK，其主要使用了SACK来告诉发送方有哪些数据被重复接收了。

#### ACK丢包

接收方发给发送方的两个ACK确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000\~3499）。于是「接收方」发现数据是重复收到的，于是回了一个SACK=3000\~3500，告诉发送方3000\~3500的数据早已被接收了，因为ACK都到了4000了，已经意味着4000之前的所有数据都已收到，所以这个SACK就代表着D-SACK。这样发送方就知道了，数据没有丢，是接收方的ACK确认报文丢了。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img10.png)

#### 网络延时

数据包（1000\~1499）被网络延迟了，导致发送方没有收到Ack1500的确认报文。而后面报文到达的三个相同的ACK确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000\~1499）又到了接收方。所以接收方回了一个SACK=1000\~1500，因为ACK已经到了3000，所以这个SACK是D-SACK，表示收到了重复的包。这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延迟了。

![](E:\GongZuoQu\KTZhiShiKu\Image\WangLuoGongCheng\TCPXieYi_img11.png)

可见，D-SACK有这么几个好处：可以让发送方知道，是发出去的包丢了，还是接收方回应的ACK包丢了；可以知道是不是发送方的数据包被网络延迟了；可以知道网络中是不是把发送方的数据包给复制了。