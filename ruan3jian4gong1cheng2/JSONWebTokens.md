## JSONWebTokens(JWT)

JWT 全称 JSON Web Tokens，是一个非常轻巧的规范。这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。它的两大使用场景是：认证和数据交换。

> RFC 提出 JWT 技术规范，出发点是一套通用的规范，考虑的范围是所有开发者，而不仅仅局限于一个开发者团队。就像用 token 做认证已经是很常见的技术了，但是 JWT 的提出就相当于提出了一套较为通用的技术规范。

###  JWT 的组成

一个 JWT 是一个字符串，它由三部分组成，头部、载荷与签名，三者中间用`.`分隔。
例如：`xxxxx.yyyyy.zzzzz`。

#### 头部(header)

头部通常由两部分组成：令牌的类型和使用的签名算法。例如：

```json
{
  "typ": "JWT",
  "alg": "HS256"
}
```

将上面的 **json** 进行 **Base64Url** 编码得到 **头部**，即 `xxxxx`。

#### 载荷(Payload)

载荷中放置了 token 的一些基本信息，以帮助接受它的服务器来理解这个 token。同时还可以包含一些自定义的信息，用户信息交换。

载荷的属性也分三类：

- 预定义(registered)
- 公有(public)
- 私有(private)

**预定义的载荷**

```json
{
  "sub": "1",
  "iss": "http://localhost:8000/auth/login",
  "aud": "dev",
  "iat": 1451888119,
  "exp": 1454516119,
  "nbf": 1451888119,
  "jti": "37c107e4609ddbcc9c096ea5ee76c667"
}
```

这里面的 7 个字段都是由官方所定义的，也就是预定义的，但并不都是必需的。

- sub(subject)：主题
- iss(issuer)：签发人
- aud(audience)：受众
- iat(Issued at)：签发时间
- exp(expiration time)：过期时间
- nbf(not before)：生效时间
- jti (JWT ID)：编号

**公有的载荷**

在使用 JWT 时可以额外定义的载荷。为了避免冲突，应该使用 [IANA JSON Web Token Registry](https://www.iana.org/assignments/jwt/jwt.xhtml) 中定义好的，或者给额外载荷加上类似命名空间的唯一标识。

**私有载荷**

在信息交互的双方之间约定好的，既不是预定义载荷也不是公有载荷的一类载荷。这一类载荷可能会发生冲突，所以应该谨慎使用。

将上面的 **json** 进行 **Base64Url** 编码得到载荷，即 `yyyyy`。

> 这里三种载荷的定义，它并不是限死了你一定要用什么样的数据结构，而是对你可能会定义出来的载荷做一个分类。在实际应用中，团队通常都是约定好要使用的载荷的数据结构。

#### 签名(Signature)

签名时需要用到前面编码过的两个字符串，将头部 `xxxxx` 与载荷 `yyyyy` 用 `.` 连接。然后对整体字符串加密。常用的加密算法有 `RS256` 和 `HS256`。将加密后的到的字符串进行 **Base64Url** 编码得到签名，即 `zzzzz`。组合便可以得到 `token：xxxxx.yyyyy.zzzzz`。

> 签名的作用是保证 JWT 没有被篡改过。当客户端把 token 发给服务端后，服务端可以把其中的头部和载荷再加一次密，将得到的结果和 token 的签名进行对比，如果一样则表明数据没有被篡改。

> RS256(采用 SHA-256 的 RSA 签名) 是一种非对称算法，它使用公钥/私钥对：标识提供方采用私钥生成签名，JWT 的使用方获取公钥以验证签名。由于公钥 (与私钥相比) 不需要保护，因此大多数标识提供方使其易于使用方获取和使用 (通常通过一个元数据URL)。
>
> HS256(带有 SHA-256 的 HMAC 是一种对称算法，双方之间仅共享一个密钥。由于使用相同的密钥生成签名和验证签名，因此必须注意确保密钥不被泄密。

### JWT 的优势

#### 无状态

JWT 的有效期完全与其载荷中编码的过期时间，服务端不维护任何状态，因此 JWT 一般是无状态的。无状态最大的优势在于三点：

- 节省服务器的资源：服务端无需维护一个状态。
- 适合分布式：因为服务端无需维护状态，因此如果服务端是多台服务器组成的分布式集群，那么不会出现一台服务器维护了状态而其他的服务器没有维护状态的情况。
- 时间换空间：因为 token 的校验是通过签名校验来进行的，签名校验消耗的是 CPU 时间，而 session 的校验是需要通过客户端提供的凭据对服务端现有的状态进行一次查询，消耗的是 I/O 和内存、磁盘空间。通常对于一个 Web 服务来说，其属于 I/O 密集型，因此通过时间换空间这一操作，可以提高整体的硬件使用率。

#### 编码数据

因为 JWT 能够在载荷中编码了部分信息，所以如果把常用数据编码进去的话，能够大大减少数据库的查询次数，不过有两点需要额外注意的：

- 载荷信息是明文编码的，所以不能编码敏感信息在里面，如果要编码可以先加密再编码进去。
- token 在每次请求时都会进行传输，所以载荷中不能编码过多的信息，否则会降低传输效率。

所以 JWT 就有四个优点了：

- 防 CSRF
- 适合移动应用
- 无状态
- 编码数据

前两个是 token 的优势，后两个是 JWT 独特的优势。

### JWT 的问题

#### 注销问题

因为 JWT 是无状态的，所以它的有效期完全由其本身决定，也就是说服务端无法让一个 token 失效。

#### 续签和刷新问题

续签和刷新的问题主要体现在，过期时间的设置，刷新时间的设置，还有刷新 token 的手段。

对于有没有必要每次都刷新的问题，取决于具体的使用场景，每次刷新 token 有：能够实现续签；能够解决重放；更安全等优点。但是也有：CPU 消耗；在并发环境下如何保证有效性等问题。

> 对于 Laravel 的 [jwt-auth](https://github.com/tymondesigns/jwt-auth) 这个库的黑名单功能，即刷新 token 后将旧 token 放入黑名单，然后生成一个新的 token，并由此产生的黑名单存储的问题。
> 
> 这个问题的解决，取决于具体的续签和刷新的策略，黑名单本身并不是必要的。设计思路不需要局限在某一种框架内，设计或者改进一个功能的目的是为了解决问题。

#### 安全问题

##### token 被盗

因为 token 中包含了登陆状态，因此一旦 token 被盗，那么就会被人盗用身份。

##### 重放攻击

重放攻击是通过把原先的包进行一次重放来进行攻击的手段。需要先明确是的 cookie + session 也是存在重放攻击的问题的。

### JWT 适合用来作什么

1. 无状态的 RESTful API
2. SSO 单点登录

## 参考

- [JWT 超详细分析 ](https://learnku.com/articles/17883#de9435)
- [JWT 完整使用详解 ](https://learnku.com/articles/10885/full-use-of-jwt)
- [JWT签名算法中HS256和RS256有什么区别](https://www.jianshu.com/p/cba0dfe4ad4a)