## 无向图

### 使用邻接矩阵存储无向图

无向图可以用一个列表，通过顶点对，间接表示。无向图这里的顶点对不需要表示顶点的先后顺序。

```php
['V0', 'V1'], ['V0', 'V5'],
['V1', 'V2'], ['V1', 'V8'], ['V1', 'V6'],
['V2', 'V3'], ['V2', 'V8'],
['V3', 'V4'], ['V3', 'V6'], ['V3', 'V7'], ['V3', 'V8'],
['V4', 'V5'], ['V4', 'V7'],
['V5', 'V6'],
['V6', 'V7'],
```

实际应用中，顶点不一定是连续的数字，而且也不一定是从0开始的，所以需要额外的对顶点做一次映射。比如上面那个列表映射出的顶点列表和对应的坐标列表是：

```json
{"V0":0,"V1":1,"V5":2,"V2":3,"V8":4,"V6":5,"V3":6,"V4":7,"V7":8}
```

最终生成的邻接矩阵是这样的：
$$
\begin{matrix}
 &  & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
 &  & V0 & V1 & V5 & V2 & V8 & V6 & V3 & V4 & V7 \\
0 & V0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
1 & V1 & 1 & 0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 \\
2 & V5 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 \\
3 & V2 & 0 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 \\
4 & V8 & 0 & 1 & 0 & 1 & 0 & 0 & 1 & 0 & 0 \\
5 & V6 & 0 & 1 & 1 & 0 & 0 & 0 & 1 & 0 & 1 \\
6 & V3 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 1 & 1 \\
7 & V4 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 \\
9 & V7 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0
\end{matrix}
$$

通常我们把纵坐标认为是边的出发点，横坐标认为是边的到达点。图中的[V0,V1]=1就表示，原来的无向图中有(V0,V1)这条边。需要注意的是：邻接矩阵并不是唯一的，矩阵的最终形态取决于顶点和下标的映射关系。

##### 无向图的遍历

无向图的遍历方式有两种，深度优先遍历和广度优先遍历。

深度优先遍历：是指在遍历过程中，一旦发现连通的新的顶点，就移动到新的顶点。并从新的顶点出发继续遍历。新的顶点遍历完了再返回老的顶点继续遍历，直到所有的顶点都被访问到。

广度优先遍历：是指在遍历过程中，先把一个顶点遍历结束，找到所有连通的新的顶点。然后依次遍历这些新的顶点，再找到和这些顶点连通的新的顶点。这里可以借助队列处理顶点先后遍历的顺序。

### 使用邻接表存储无向图

对于顶点数量多但是边的数量少的无向图，使用邻接矩阵会很浪费空间。这个时候参考线性表的顺序存储结构和链式存储结构，同理我们可以使用链表结构保存无向图。具体的做法是，顶点依然使用数组存储，但是边的关系使用链表存储。

构造出来的结构大概是这样的：

> |0->V0| => 1 => 2
> |1->V1| => 0 => 3 => 4 => 5
> |2->V5| => 0 => 7 => 5
> ...

这里是一部分结构，左边的 `|0->V0|` 表示顶点数组的下标和对应的顶点，`|0->V0| => 1 => 2` 右边的链表表示与顶点V0之间存在边的顶点的下标。比如 `=> 2` 表示顶点V0和下标为2的顶点V5之间有边。

邻接表的深度优先遍历和广度优先遍历都的思路和邻接矩阵类似，就是数组换成了链表。

### 普里姆算法

普里姆算法是用来寻找带权重图的最小生成树的。

过程是这样的：

- 1、首先在图中随便找一个顶点作为起始顶点。
- 2、寻找从这个顶点开始的最小权重的边，这个时候会连带着一个顶点。
- 3、把这个新的顶点和起始顶点看作一个整体，再次作为起始顶点。
- 4、重复上述步骤2和步骤3，直到所有的顶点都被连进来。这个过程中需要注意不要出现环状结构。

### 克鲁斯卡尔算法

克鲁斯卡尔算法是用来寻找带权重图的最小生成树的。与普里姆算法的区别在于，普里姆算法从顶点着手，克鲁斯卡尔算法从边着手。

过程是这样的：

- 1、首先把图中所有的边按照权重从小到大排序。
- 2、找出最小权重的边，判断两个顶点是不是已经在最小生成树上了，如果已经在生成树上了，这个地方的边连起来就会形成环状结构。
- 3、重复上述步骤2，直到所有的顶点都被连进来。

### 迪杰斯特拉算法

迪杰斯特拉算法是用来寻找从一个顶点出发到其余顶点的最短路径的算法。它会按路径长度递增的次序产生最短路径（判断的过程，每次确认一个顶点）。

过程是这样的：

- 1、首先确认起始顶点1。
- 2、找到从起始顶点出发路径权重最小的顶点2，这个顶点2即为本次可以确认最短路径的顶点，最小路径也是很明显的，标记顶点2的最小路径来源是顶点1。
- 3、以刚才两个顶点为基础找到从这两个顶点出发，路径权重最小的顶点3，这个顶点3即为本次确认最短路径的顶点，将刚才选的最小权重的路径和已经找到最短路径的顶点做一下比对，判断有没有别的更短的路径。最终标记顶点3从哪个顶点来路径最短，标记路径最短的顶点为顶点3的路径来源。
- 4、重复上述步骤3，直到所有的顶点都确认完毕。

### 弗洛伊德算法



| 代码说明       | 代码位置                                           |
| -------------- | -------------------------------------------------- |
| 普里姆算法     | CYangLi/shu4ju4jie2gou4/pu3li3mu3suan4fa3.c        |
| 克鲁斯卡尔     | CYangLi/shu4ju4jie2gou4/ke4lu3si1ka3er3suan4fa3.c  |
| 迪杰斯特拉算法 | CYangLi/shu4ju4jie2gou4/di2jie2si1te4la1suan3fa3.c |
| 弗洛伊德算法   | CYangLi/shu4ju4jie2gou4/fu2luo4yi1de2suan4fa3.c    |