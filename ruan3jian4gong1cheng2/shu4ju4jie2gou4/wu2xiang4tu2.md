## 无向图

### 使用邻接矩阵存储无向图

无向图可以用一个列表，通过顶点对，间接表示。无向图这里的顶点对不需要表示顶点的先后顺序。

```php
['V0', 'V1'], ['V0', 'V5'],
['V1', 'V2'], ['V1', 'V8'], ['V1', 'V6'],
['V2', 'V3'], ['V2', 'V8'],
['V3', 'V4'], ['V3', 'V6'], ['V3', 'V7'], ['V3', 'V8'],
['V4', 'V5'], ['V4', 'V7'],
['V5', 'V6'],
['V6', 'V7'],
```

实际应用中，顶点不一定是连续的数字，而且也不一定是从0开始的，所以需要额外的对顶点做一次映射。比如上面那个列表映射出的顶点列表和对应的坐标列表是：

```json
{"V0":0,"V1":1,"V5":2,"V2":3,"V8":4,"V6":5,"V3":6,"V4":7,"V7":8}
```

最终生成的邻接矩阵是这样的：
$$
\begin{matrix}
 &  & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
 &  & V0 & V1 & V5 & V2 & V8 & V6 & V3 & V4 & V7 \\
0 & V0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
1 & V1 & 1 & 0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 \\
2 & V5 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 \\
3 & V2 & 0 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 \\
4 & V8 & 0 & 1 & 0 & 1 & 0 & 0 & 1 & 0 & 0 \\
5 & V6 & 0 & 1 & 1 & 0 & 0 & 0 & 1 & 0 & 1 \\
6 & V3 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 1 & 1 \\
7 & V4 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 \\
9 & V7 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0
\end{matrix}
$$

通常我们把纵坐标认为是边的出发点，横坐标认为是边的到达点。图中的[V0,V1]=1就表示，原来的无向图中有(V0,V1)这条边。需要注意的是：邻接矩阵并不是唯一的，矩阵的最终形态取决于顶点和下标的映射关系。

##### 无向图的遍历

无向图的遍历方式有两种，深度优先遍历和广度优先遍历。

深度优先遍历：是指在遍历过程中，一旦发现连通的新的顶点，就移动到新的顶点。并从新的顶点出发继续遍历。新的顶点遍历完了再返回老的顶点继续遍历，直到所有的顶点都被访问到。

广度优先遍历：是指在遍历过程中，先把一个顶点遍历结束，找到所有连通的新的顶点。然后依次遍历这些新的顶点，再找到和这些顶点连通的新的顶点。这里可以借助队列处理顶点先后遍历的顺序。

### 使用邻接表存储无向图

对于顶点数量多但是边的数量少的无向图，使用邻接矩阵会很浪费空间。这个时候参考线性表的顺序存储结构和链式存储结构，同理我们可以使用链表结构保存无向图。具体的做法是，顶点依然使用数组存储，但是边的关系使用链表存储。

构造出来的结构大概是这样的：

> |0->V0| => 1 => 2
> |1->V1| => 0 => 3 => 4 => 5
> |2->V5| => 0 => 7 => 5
> ...

这里是一部分结构，左边的 `|0->V0|` 表示顶点数组的下标和对应的顶点，`|0->V0| => 1 => 2` 右边的链表表示与顶点V0之间存在边的顶点的下标。比如 `=> 2` 表示顶点V0和下标为2的顶点V5之间有边。

邻接表的深度优先遍历和广度优先遍历都的思路和邻接矩阵类似，就是数组换成了链表。

## 普里姆算法

普里姆算法是用来寻找带权重无向图的最小生成树的。

过程是这样的：

- 1、首先在无向图中随便找一个顶点作为起始顶点。
- 2、寻找从这个顶点开始的最小权重的边，这个时候会连带着一个顶点。
- 3、把这个新的顶点和起始顶点看作一个整体，再次作为起始顶点。
- 4、重复上述步骤2和步骤3，直到所有的顶点都被连进来。这个过程中需要注意不要出现环状结构。

首先我们要把邻接矩阵的代码搬过来。有区别的地方是，构造邻接矩阵这里需要做一点修改，普通的邻接矩阵没有权重。

原先邻接矩阵的0值表示两个顶点之间没有连线。这包括了两种情况，真的没有连线和自身到自身没有连线。在这里自身到自身没有连线依然标记为0，但是真的没有连线的情况需要找一个临界值来标记，这个临界值要大于任何一个权重，比如65535。

有了邻接矩阵就可以开始实现普里姆算法了，当然邻接表也可以，思路都是一样的。就用上面描述的思路，需要注意的是怎么标记从最小生成树顶点出发的所有的边和这些边的起始顶点。这里需要结合代码来解释。

初始化时：

```json
$zuiXiaoQuanZhongLieBiao = [0,10,11,65535,65535,65535,65535,65535,65535]
$xiangGuanDingDianLieBiao = [0,0,0,0,0,0,0,0,0]
```

`$zuiXiaoQuanZhongLieBiao`表示：V0已经在最小生成树中；从V0=>V1有路径，权重为10；从V0=>V3，没有路径，所以权重为临界值65535。

`$xiangGuanDingDianLieBiao`表示：所有的有效的路径都从顶点V0出发。

第一次循环，上面的10是权重最小的，所以V1顶点被放入最小生成树。循环结束时：

```json
$zuiXiaoQuanZhongLieBiao = [0,0,11,18,12,16,65535,65535,65535]
$xiangGuanDingDianLieBiao = [0,0,0,1,1,1,0,0,0]
$zuiXiaoShenChengShu = [["V0","V1"]]
```

`$zuiXiaoQuanZhongLieBiao`表示：V0和V1已经在最小生成树中；从最小生成树=>V2有路径，权重为11；从从最小生成树=>V3，有路径，所以权重为18。这个18是V1顶点被加入最小生成树之后扩充出来的边。

`$xiangGuanDingDianLieBiao`表示：所有的有效的路径现在会分别从V0顶点和V1顶点出发。

`$zuiXiaoShenChengShu`表示最小生成树找到了一条边 (V0,V1)。

后续的循环都仿照上面的思路。

## 克鲁斯卡尔算法

克鲁斯卡尔算法是用来寻找带权重无向图的最小生成树的。与普里姆算法的区别在于，普里姆算法从顶点着手，克鲁斯卡尔算法从边着手。

过程是这样的：

- 1、首先把无向图中所有的边按照权重从小到大排序。
- 2、找出最小权重的边，判断两个顶点是不是已经在最小生成树上了，如果已经在生成树上了，这个地方的边连起来就会形成环状结构。
- 3、重复上述步骤2，直到所有的顶点都被连进来。

克鲁斯卡尔算法并不需要邻接矩阵或者邻接表。它需要另外一个东西，按权重排序的路径列表。初始化的时候，需要把无向图的路径参数处理成这样的一张表。

有了列表之后，从权重最小的路径开始，每次把边和边相关的两个顶点加入最小生成树。这里需要注意的是，在算法执行的过程中会同时存在多个独立的子树，但是最终它们连起来成为一棵树。

在构造最小生成树的过程中，每次循环处理的都是当前有效的权重最小的边。在处理边的时候需要检查两个顶点是不是已经处于任何一棵最小生成树上。