## 图(Graph)

非线性结构，顶点，边(弧)，环(回路)

无向图，边无方向`(i,j)`，度

有向图，边有方向`<i,j>`，入度，出度

带权图，边有权重

邻接矩阵，二维数组，顶点i到顶点j有边表示为：`arr[i][j]=1`，浪费空间，查询块，可以矩阵运算

邻接表，散列表+链表，节省空间，查询慢，链表可以换其他合适的结构，逆邻接表

邻接矩阵，邻接表，空间换时间

广度(层次)优先搜索，队列

深度优先搜索，回溯(递归，栈)

### 使用场景

##### 社交网络中的好友关系

双向关注，无向图，单向关注，有向图

每个用户的关系数和总用户数量不在一个量级，所以用邻接表

如果要按照一定的顺序给好友排序，可以使用跳表替换链表

同时存储邻接表和逆邻接表可以加快查询速度

巨量的数据可以通过哈希分片的方式存储在不同的机器上

##### 在计算机中保存迷宫

迷宫就可以抽象成图结构，每个岔路口或者死路就是顶点，路径需要根据顶点，一段一段的存储

### 最小生成树

##### 普里姆算法

普里姆算法是用来寻找带权重图的最小生成树的。

在图中随便找一个顶点作为起始顶点，寻找从这个顶点出发的权重最小的边，这个时候会连带着一个顶点。把这个连带着的顶点和起始顶点看作一个整体，作为整体起始顶点。寻找从这个整体起始顶点出发的权重最小的边。

重复上述步骤，直到所有的顶点都被连进这个整体起始顶点。这个过程中需要注意不要出现环状结构，找到权重最小的边的时候，判断一下连带着的顶点是不是已经是整体起始顶点内的顶点了。

##### 克鲁斯卡尔算法

克鲁斯卡尔算法是用来寻找带权重图的最小生成树的。

与普里姆算法的区别在于，普里姆算法从顶点着手，克鲁斯卡尔算法从边着手。

首先把图中所有的边按照权重从小到大排序。

找出权重最小的边，得到两个顶点(比如，顶点a和顶点b)。把这两个顶点记录到一个表中，用于表示一条边，(a,b)或(b,a)都可以。

向后查找第二小的边，如果的到另外两个顶点，就把这两个顶点记录到表中。如果的到的顶点是表中已经存在的顶点，则需要分别追溯这两个顶点，判断是否会有环产生。

比如，表中已经有(a,b),(b,c),(a,d)三条边了，这个时候有一条(d,c)边。顶点d可以通过(a,d)追溯到顶点a，顶点c可以通过(b,c),(a,b)追溯到顶点a。这种情况就说明，这条边加进来会构成环路。

重复上述步骤，直到所有的顶点都被记录到表中。

##### 迪杰斯特拉算法

迪杰斯特拉算法是用来寻找从一个顶点出发到其余顶点的最短路径的算法。它会按路径长度递增的次序产生最短路径（判断的过程，每次确认一个顶点）。

- 1、首先确认起始顶点1。
- 2、找到从起始顶点出发路径权重最小的顶点2，这个顶点2即为本次可以确认最短路径的顶点，最小路径也是很明显的，标记顶点2的最小路径来源是顶点1。
- 3、以刚才两个顶点为基础找到从这两个顶点出发，路径权重最小的顶点3，这个顶点3即为本次确认最短路径的顶点，将刚才选的最小权重的路径和已经找到最短路径的顶点做一下比对，判断有没有别的更短的路径。最终标记顶点3从哪个顶点来路径最短，标记路径最短的顶点为顶点3的路径来源。
- 4、重复上述步骤3，直到所有的顶点都确认完毕。

##### 弗洛伊德算法

对于从顶点A到顶点B的最短路径，拿出网中所有的顶点K依次进行判断，如果（A，K）+（B，K）<（A，B）成立，那么就存在一条权值更小的路径（A，K，B），所以更新（A，B）的最短路径。最终遍历完成后记录的最终的权值即为对应顶点之间的最短路径。

| 代码说明       | 代码位置                                           |
| -------------- | -------------------------------------------------- |
| 普里姆算法     | CYangLi/shu4ju4jie2gou4/pu3li3mu3suan4fa3.c        |
| 克鲁斯卡尔     | CYangLi/shu4ju4jie2gou4/ke4lu3si1ka3er3suan4fa3.c  |
| 迪杰斯特拉算法 | CYangLi/shu4ju4jie2gou4/di2jie2si1te4la1suan3fa3.c |
| 弗洛伊德算法   | CYangLi/shu4ju4jie2gou4/fu2luo4yi1de2suan4fa3.c    |