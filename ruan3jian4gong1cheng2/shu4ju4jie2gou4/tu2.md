## 图(Graph)

非线性结构，顶点，边(弧)，环(回路)

无向图，边无方向`(i,j)`，度

有向图，边有方向`<i,j>`，入度，出度

带权图，边有权重

邻接矩阵，二维数组，顶点i到顶点j有边表示为：`arr[i][j]=1`，浪费空间，查询块，可以矩阵运算

邻接表，散列表+链表，节省空间，查询慢，链表可以换其他合适的结构，逆邻接表

邻接矩阵，邻接表，空间换时间

广度(层次)优先搜索，队列

深度优先搜索，回溯(递归，栈)

### 使用场景

##### 社交网络中的好友关系

双向关注，无向图，单向关注，有向图

每个用户的关系数和总用户数量不在一个量级，所以用邻接表

如果要按照一定的顺序给好友排序，可以使用跳表替换链表

同时存储邻接表和逆邻接表可以加快查询速度

巨量的数据可以通过哈希分片的方式存储在不同的机器上

##### 在计算机中保存迷宫

迷宫就可以抽象成图结构，每个岔路口或者死路就是顶点，路径需要根据顶点，一段一段的存储

### 最小生成树

##### 普里姆算法

普里姆算法是用来寻找带权重图的最小生成树的。

在图中随便找一个顶点作为起始顶点，寻找从这个顶点出发的权重最小的边，这个时候会连带着一个顶点。把这个连带着的顶点和起始顶点看作一个整体，作为整体起始顶点。寻找从这个整体起始顶点出发的权重最小的边。

重复上述步骤，直到所有的顶点都被连进这个整体起始顶点。这个过程中需要注意不要出现环状结构，找到权重最小的边的时候，判断一下连带着的顶点是不是已经是整体起始顶点内的顶点了。

##### 克鲁斯卡尔算法

克鲁斯卡尔算法是用来寻找带权重图的最小生成树的。

与普里姆算法的区别在于，普里姆算法从顶点着手，克鲁斯卡尔算法从边着手。

首先把图中所有的边按照权重从小到大排序。

找出权重最小的边，得到两个顶点(比如，顶点a和顶点b)。把这两个顶点记录到一个表中，用于表示一条边，(a,b)或(b,a)都可以。

向后查找第二小的边，如果的到另外两个顶点，就把这两个顶点记录到表中。如果的到的顶点是表中已经存在的顶点，则需要分别追溯这两个顶点，判断是否会有环产生。

比如，表中已经有(a,b),(b,c),(a,d)三条边了，这个时候有一条(d,c)边。顶点d可以通过(a,d)追溯到顶点a，顶点c可以通过(b,c),(a,b)追溯到顶点a。这种情况就说明，这条边加进来会构成环路。

重复上述步骤，直到所有的顶点都被记录到表中。

##### 迪杰斯特拉(Dijkstra)算法

用来寻找从一个顶点出发到其余顶点的最短路径，它会按路径长度递增的次序产生最短路径

需要维护两个数据，顶点到各个顶点的最短路径(没找到时填临界值)，顶点的最短路径的来源顶点

首先选定起始顶点1，自身到自身最短路径为0，然后遍历从这个点出发的边，依次更新到各个顶点的最短路径

遍历顶点1到各个未确认顶点的最短路径，找到路径值最小的那个顶点2，顶点2就是本次可以确定最短路径的顶点

然后遍历从顶点2出发的边，依次更新顶点1到各个未确认顶点的最短路径

重复上述步骤，直到所有的顶点都确认完毕

##### 弗洛伊德(Floyd)算法

对于从顶点A到顶点B的最短路径，拿出网中所有的顶点K依次进行判断，如果（A，K）+（B，K）<（A，B）成立，那么就存在一条权值更小的路径（A，K，B），所以更新（A，B）的最短路径。最终遍历完成后记录的最终的权值即为对应顶点之间的最短路径。

---

| 代码说明       | 代码位置                                           |
| -------------- | -------------------------------------------------- |
| 普里姆算法     | CYangLi/shu4ju4jie2gou4/pu3li3mu3suan4fa3.c        |
| 克鲁斯卡尔     | CYangLi/shu4ju4jie2gou4/ke4lu3si1ka3er3suan4fa3.c  |
| 迪杰斯特拉算法 | CYangLi/shu4ju4jie2gou4/di2jie2si1te4la1suan3fa3.c |
| 弗洛伊德算法   | CYangLi/shu4ju4jie2gou4/fu2luo4yi1de2suan4fa3.c    |