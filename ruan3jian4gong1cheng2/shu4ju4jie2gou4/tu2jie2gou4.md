## 图结构

图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。线性表中的数据元素叫元素，树中的数据元素叫结点，图中的数据元素叫顶点。图结构中，不允许没有顶点，集合V是有穷非空集合。图结构中，任意两个顶点之间都有可能有关系，顶点之间的逻辑关系用边来表示。

### 相关定义

- 无向边：顶点vi到vj之间的边没有方向，用无序偶对（vi,vj）表示。
- 无向图：图中任意两个顶点之间的边都是无向边。
- 有向边：从顶点vi到vj之间的边有方向，也称为弧，用有序偶对<vi,vj>表示，vi称为弧尾，vj称为弧头。
- 有向图：图中任意两个顶点之间的边都是有向边。
- 简单图：在图中不存在顶点到其自身的边，且同一条边不重复出现。
- 无向完全图：无向图中，任意两个顶点之间都存在边。
- 有向完全图：有向图中，任意两个顶点之间都存在方向互为相反的两条弧。
- 有很少条边或弧的图称为稀疏图，反之就是稠密图，这是个相对概念。
- 权：与图的边或弧相关的数。
- 网：带权的图。
- 子图：假设有两个图G(V,E)，G(V1,E1)，如果$V1 \subseteq V2且E1 \subseteq E$，则G1是G的子图。

### 顶点与边的关系

对于无向图G=(V,E)，如果边$(V,V1) \in E$，则称顶点V和V1互为邻接点，V和V1相邻接。边（V,V1）依附于顶点V和V1，或者边（V,V1）和顶点V和V1相关联。顶点的度是和顶点相关联的边的数目。

对于有向图G=(V,E)，如果弧$<V,V1> \in E$，则称顶点V邻接到顶点V1，顶点V1邻接自顶点V。弧<V,V1>和顶点V和V1相关联。顶点的入度是以顶点为头的弧的数目，顶点的出度是以顶点为尾的弧的数目。

路径的长度是路径上的边或弧的数目。

第一个顶点到最后一个顶点，如果最后一个顶点和第一个顶点相同，则称这种路径为回路或者环。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，成为简单回路或者简单环。

### 连通图相关

在无向图G中，如果从顶点V到顶点V1有路径，则称V和V1是连通的，如果对于图中任意两个顶点，都是连通的，则称G是连通图。

无向图的极大连通子图称为连通分量。连通分量：1、要是子图；2、子图要是连通的；3、连通子图含有极大顶点数；4、具有极大顶点数的连通子图包含依附于这些顶点的所有边。

在有向图G中，如果对于每一对V1，V2，从V1到V2和从V2到V1都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。

连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。

如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一颗有向树。

一个有向图生成的森林由若干棵有向树组成，含有图中的全部顶点，但只有足以构成若干棵不相交的有向树的弧。

### 无向图

##### 使用邻接矩阵存储无向图

无向图可以用一个列表，通过顶点对，间接表示。无向图这里的顶点对不需要表示顶点的先后顺序。

```php
['V0', 'V1'], ['V0', 'V5'],
['V1', 'V2'], ['V1', 'V8'], ['V1', 'V6'],
['V2', 'V3'], ['V2', 'V8'],
['V3', 'V4'], ['V3', 'V6'], ['V3', 'V7'], ['V3', 'V8'],
['V4', 'V5'], ['V4', 'V7'],
['V5', 'V6'],
['V6', 'V7'],
```

实际应用中，顶点不一定是连续的数字，而且也不一定是从0开始的，所以需要额外的对顶点做一次映射。比如上面那个列表映射出的顶点列表和对应的坐标列表是：

```json
{"V0":0,"V1":1,"V5":2,"V2":3,"V8":4,"V6":5,"V3":6,"V4":7,"V7":8}
```

最终生成的邻接矩阵是这样的：
$$
\begin{matrix}
 &  & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
 &  & V0 & V1 & V5 & V2 & V8 & V6 & V3 & V4 & V7 \\
0 & V0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
1 & V1 & 1 & 0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 \\
2 & V5 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 \\
3 & V2 & 0 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 \\
4 & V8 & 0 & 1 & 0 & 1 & 0 & 0 & 1 & 0 & 0 \\
5 & V6 & 0 & 1 & 1 & 0 & 0 & 0 & 1 & 0 & 1 \\
6 & V3 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 1 & 1 \\
7 & V4 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 \\
9 & V7 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0
\end{matrix}
$$

通常我们把纵坐标认为是边的出发点，横坐标认为是边的到达点。图中的[V0,V1]=1就表示，原来的无向图中有(V0,V1)这条边。需要注意的是：邻接矩阵并不是唯一的，矩阵的最终形态取决于顶点和下标的映射关系。

##### 无向图的遍历

无向图的遍历方式有两种，深度优先遍历和广度优先遍历。

深度优先遍历：是指在遍历过程中，一旦发现连通的新的顶点，就移动到新的顶点。并从新的顶点出发继续遍历。新的顶点遍历完了再返回老的顶点继续遍历，直到所有的顶点都被访问到。

广度优先遍历：是指在遍历过程中，先把一个顶点遍历结束，找到所有连通的新的顶点。然后依次遍历这些新的顶点，再找到和这些顶点连通的新的顶点。这里可以借助队列处理顶点先后遍历的顺序。

##### 使用邻接表存储无向图

对于顶点数量多但是边的数量少的无向图，使用邻接矩阵会很浪费空间。这个时候参考线性表的顺序存储结构和链式存储结构，同理我们可以使用链表结构保存无向图。具体的做法是，顶点依然使用数组存储，但是边的关系使用链表存储。

构造出来的结构大概是这样的：

> |0->V0| => 1 => 2
> |1->V1| => 0 => 3 => 4 => 5
> |2->V5| => 0 => 7 => 5
> ...

这里是一部分结构，左边的 `|0->V0|` 表示顶点数组的下标和对应的顶点，`|0->V0| => 1 => 2` 右边的链表表示与顶点V0之间存在边的顶点的下标。比如 `=> 2` 表示顶点V0和下标为2的顶点V5之间有边。

邻接表的深度优先遍历和广度优先遍历都的思路和邻接矩阵类似，就是数组换成了链表。

##### 普里姆算法

普里姆算法是用来寻找带权重图的最小生成树的。

- 1、首先在图中随便找一个顶点作为起始顶点。
- 2、寻找从这个顶点开始的最小权重的边，这个时候会连带着一个顶点。
- 3、把这个新的顶点和起始顶点看作一个整体，再次作为起始顶点。
- 4、重复上述步骤2和步骤3，直到所有的顶点都被连进来。这个过程中需要注意不要出现环状结构。

##### 克鲁斯卡尔算法

克鲁斯卡尔算法是用来寻找带权重图的最小生成树的。与普里姆算法的区别在于，普里姆算法从顶点着手，克鲁斯卡尔算法从边着手。

- 1、首先把图中所有的边按照权重从小到大排序。
- 2、找出最小权重的边，判断两个顶点是不是已经在最小生成树上了，如果已经在生成树上了，这个地方的边连起来就会形成环状结构。
- 3、重复上述步骤2，直到所有的顶点都被连进来。

##### 迪杰斯特拉算法

迪杰斯特拉算法是用来寻找从一个顶点出发到其余顶点的最短路径的算法。它会按路径长度递增的次序产生最短路径（判断的过程，每次确认一个顶点）。

- 1、首先确认起始顶点1。
- 2、找到从起始顶点出发路径权重最小的顶点2，这个顶点2即为本次可以确认最短路径的顶点，最小路径也是很明显的，标记顶点2的最小路径来源是顶点1。
- 3、以刚才两个顶点为基础找到从这两个顶点出发，路径权重最小的顶点3，这个顶点3即为本次确认最短路径的顶点，将刚才选的最小权重的路径和已经找到最短路径的顶点做一下比对，判断有没有别的更短的路径。最终标记顶点3从哪个顶点来路径最短，标记路径最短的顶点为顶点3的路径来源。
- 4、重复上述步骤3，直到所有的顶点都确认完毕。

##### 弗洛伊德算法



| 代码说明       | 代码位置                                           |
| -------------- | -------------------------------------------------- |
| 普里姆算法     | CYangLi/shu4ju4jie2gou4/pu3li3mu3suan4fa3.c        |
| 克鲁斯卡尔     | CYangLi/shu4ju4jie2gou4/ke4lu3si1ka3er3suan4fa3.c  |
| 迪杰斯特拉算法 | CYangLi/shu4ju4jie2gou4/di2jie2si1te4la1suan3fa3.c |
| 弗洛伊德算法   | CYangLi/shu4ju4jie2gou4/fu2luo4yi1de2suan4fa3.c    |