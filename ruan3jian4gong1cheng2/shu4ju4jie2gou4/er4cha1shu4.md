## 二叉树(Binary Tree)

链式存储，左右子结点指针

顺序存储，数组，建议根结点放在下标1的位置，更容易计算父结点与子结点下标对应关系

满二叉树，完全二叉树

斜树，除了根结点外，只有左结点(左斜树)或只有右结点(右斜树)

### 性质

第i层上至多有2^i-1^个结点。

深度为h的二叉树中至多含有2^h^-1个结点。

有n0个度为0的叶子结点，有n2个度为2的结点，则n0=n2+1。对于任何一棵二叉树，假设叶子结点数为n0，度为1的结点数为n1，度为2的结点数为n2。则n0+n1+n2=n。又因为连接(分叉)数总等于总结点数n减1(除根结点外，每个子结点都要连接父结点)，得到n1+2*n2=n-1​。然后，联立方程得出结论

具有n个结点的完全二叉树深为$\lfloor\log_2(x)\rfloor+1$（其中x表示不大于n的最大整数，$\lfloor\log_2(x)\rfloor$表示对计算结果向下取整）。

若对一棵有n个结点的完全二叉树进行顺序编号（1≤i≤n），那么，对于编号为i（i≥1）的结点：

- 当i=1时，该结点为根，它无双亲结点。
- 当i>1时，该结点的双亲结点的编号为$\lfloor i/2 \rfloor$。
- 若2i≤n，则有编号为2i的左孩子，否则没有左孩子。
- 若2+1≤n，则有编号为2i+1的右孩子，否则没有右孩子。

### 遍历

前序（先序）遍历（Pre Order Traversal，NLR）：根左右

中序遍历（In Order Traversal，LNR）：左根右

后序遍历（Post Order Traversal，LRN）：左右根

广度优先（层次）遍历（Breadth First Search，BFS）：按层从左到右

深度优先遍历（Depth First Search，DFS）：从左到右，优先向下

已知前序遍历序列和中序遍历序列，可以唯一确定一课二叉树

已知中序遍历序列和后序遍历序列，可以唯一确定一课二叉树

已知前序遍历序列和后序遍历序列，不能唯一确定一课二叉树

### 线索二叉树

n个结点的二叉树，有n+1个空指针

利用这些空指针，存放在某种遍历(先序、中序、后序或层次等)次序下，该结点的前驱结点和后继结点的指针

这些指针称为线索，变为线索二叉树的过程称为对二叉树进行线索化

二叉树的遍历本质上是将一个复杂的非线性结构转换为线性结构，使每个结点都有了唯一前驱和后继（第一个结点无前驱，最后一个结点无后继）。对于二叉树的一个结点，查找其左右子女是方便的，其前驱后继只有在遍历中得到。线索链表解决了无法直接找到该结点在某种遍历序列中的前驱和后继结点的问题，解决了二叉链表找左、右孩子困难的问题。

线索二叉树的好处是：

- 1、利用线索二叉树进行中序遍历时，不必采用堆栈处理，速度较一般二叉树的遍历速度快，且节约存储空间。
- 2、任意一个结点都能直接找到它的前驱和后继结点。这里注意有左孩子的时候，前驱就是左孩子；有右孩子的时候，后继就是右孩子。

但是插入和删除的时候也需要额外的维护线索，而且子树不能使用主树的线索。

### 二叉查找(排序)树

对于树中任意结点，左子树中每个结点都比自己小，右子树中每个结点都比自己大

中序遍历可以输出有序序列，时间复杂度O(n)

删除结点的时候，可以从左子数找一个最大的，或者从右子树找一个最小的，顶替自己

支持重复数据的方案，结点维护一个链表或者数组，或者认为相同的数据比自己大，删除的时候要删全部

---

| 代码说明   | 代码位置                                        |
| ---------- | ----------------------------------------------- |
| 二叉树     | CYangLi/shu4ju4jie2gou4/er4cha1shu4.c           |
| 线索二叉树 | CYangLi/shu4ju4jie2gou4/xian4suo3er4cha1shu4.c  |
| 二叉排序树 | CYangLi/shu4ju4jie2gou4/er4cha1pai2xu4shu4.c    |
| 平衡二叉树 | CYangLi/shu4ju4jie2gou4/ping2heng2er4cha1shu4.c |


