## 散列表

数组，散列函数，装载因子(可用空间)，动态扩容(缩容)

散列函数计算得到的散列值是非负数，相同的key散列值相同，不同的key散列值不同

散列冲突无法避免，开放寻址法，链表法

开放寻址法，线性探测(步长1)，二次探测(步长2^n^)，双重探测(多个散列函数)

链表法，链表，跳表，红黑树

散列函数，不能太复杂(效率)，散列值随机且均匀(冲突)

动态扩容，不需要一次性转移数据，可以先新表老表兼容一段时间，分批搬移数据

工业级散列表，快速增删查(合适的散列函数)，内存合理(装载因子，动态扩容)，性能稳定(散列冲突)

### 基于链表和散列表实现缓存LRU淘汰算法

需要散列表和双向链表

和普通的双向链表不同的是，这里的双向链表多了一个hashnext的指针域

hashnext指针的作用是使用散列表和链表实现快速的查找

查询操作，通过散列表和链表查找，找到后把结点放到双向链表的末尾

删除操作，通过散列表和链表查找，通过双向链表高效删除

插入数据，先通过散列表和链表查找查询，找到后把结点放到双向链表的末尾，如果找不到而且内存没满，直接在双向链表的末尾加一个结点，如果内存满了，需要先删除头结点，然后在添加结点

这样就实现了一个时间复杂度是O(1)的缓存LRU淘汰算法

### Redis有序集合

有序集合的元素有两个重要的属性，键值key，分值score

实现方式是散列表(存key)和双向跳表(存score)的组合，对应Redis有序集合的操作：

- 添加元素(散列表，跳表)
- 查找元素，删除元素(散列表查，跳表删)
- 按分值区间查找数据(跳表)
- 按分值从大到小排列(跳表)