## 动态内存管理机制

对于计算机中的内存来说，称已经分配给用户的的内存区统称为占用块；还未分配出去的内存区统称为空闲块或者可利用空间块。这里的用户，不是普通意义上的用户，可能是一个普通的变量，一个应用程序，一个命令等等。只要是向系统发出内存申请的，都可以称之为用户。

### 系统的内存管理

对于初始状态下的内存来说，整个空间都是一个空闲块（在编译程序中称为堆）。但是随着不同的用户不断地提出存储请求，系统依次分配。整个内存区就会分割成两个大部分：低地址区域会产生很多占用块；高地址区域还是空闲块。但是当某些用户运行结束，所占用的内存区域就变成了空闲块。此时，就形成了占用块和空闲块交错的状态。

当后续用户请求分配内存时，系统有两种分配方式：

- 系统继续利用高地址区域的连续空闲块分配给用户，不去理会之前分配给用户的内存区域的状态。直到分配无法进行，也就是高地址的空闲块不能满足用户的需求时，系统才会去回收之前的空闲块，重新组织继续分配；
- 当用户运行一结束，系统马上将其所占空间进行回收。当有新的用户请求分配内存时，系统遍历所有的空闲块，从中找出一个合适的空闲块分配给用户。

### 可利用空间表

当采用第2种方式时，系统需要建立一张记录所有空闲块信息的表。表的形式有两种：目录表和链表。

- 目录表中每一行代表一个空闲块，由三部分组成：初始地址，记录每个空闲块的起始地址；空闲块大小，记录每个空闲块的内存大小；使用情况，记录每个空闲块是否存储被占用的状态。
- 链表中每个结点代表一个空闲块，每个结点中需要记录空闲块的使用情况、大小和连接下一个空闲块的指针域。由于链表中有指针的存在，所以结点中不需要记录各内存块的起始地址。

系统在不同的环境中运行，根据用户申请空间的不同，存储空闲块的可利用空间表有以下不同的结构：

- 如果每次用户请求的存储空间大小相同，对于此类系统中的内存来说，在用户运行初期就将整个内存存储块按照所需大小进行分割，然后通过链表链接。当用户申请空间时，从链表中摘除一个结点归其使用；用完后再链接到可利用空间表上。
- 每次如果用户申请的都是若干种大小规格的存储空间，针对这种情况可以建立若干个可利用空间表，每一个链表中的结点大小相同。当用户申请某一规格大小的存储空间时，就从对应的链表中摘除一个结点供其使用；用完后链接到相同规格大小的链表中。
- 用户申请的内存的大小不固定，所以造成系统分配的内存块的大小也不确定，回收时，链接到可利用空间表中每个结点的大小也各不一样。

第2种情况下容易面临的问题是：如果同用户申请空间大小相同的链表中没有结点时，就需要找结点更大的链表，从中取出一个结点，一部分给用户使用，剩余部分插入到相应大小的链表中；回收时，将释放的空闲块插入到大小相同的链表中去。如果没有比用户申请的内存空间相等甚至更大的结点时，就需要系统重新组织一些小的连续空间，然后给用户使用。

### 分配存储空间的方式

通常情况下系统中的可利用空间表是第3种情况。由于链表中各结点的大小不一，在用户申请内存空间时，就需要从可利用空间表中找出一个合适的结点，有三种查找的方法：

- 首次拟合法：在可利用空间表中从头开始依次遍历，将找到的第一个内存不小于用户申请空间的结点分配给用户，剩余空间仍留在链表中；回收时只要将释放的空闲块插入在链表的表头即可。
- 最佳拟合法：和首次拟合法不同，最佳拟合法是选择一块内存空间不小于用户申请空间，但是却最接近的一个结点分配给用户。为了实现这个方法，首先要将链表中的各个结点按照存储空间的大小进行从小到大排序，由此，在遍历的过程中只需要找到第一块大于用户申请空间的结点即可进行分配；用户运行完成后，需要将空闲块根据其自身的大小插入到链表的相应位置。
- 最差拟合法：和最佳拟合法正好相反，该方法是在不小于用户申请空间的所有结点中，筛选出存储空间最大的结点，从该结点的内存空间中提取出相应的空间给用户使用。为了实现这一方法，可以在开始前先将可利用空间表中的结点按照存储空间大小从大到小进行排序，第一个结点自然就是最大的结点。回收空间时，同样将释放的空闲块插入到相应的位置上。

以上三种方法各有所长：

- 最佳拟合法由于每次分配相差不大的结点给用户使用，所以会生成很多存储空间特别小的结点，以至于根本无法使用，使用过程中，链表中的结点存储大小发生两极分化，大的很大，小的很小。该方法适用于申请内存大小范围较广的系统
- 最差拟合法，由于每次都是从存储空间最大的结点中分配给用户空间，所以链表中的结点大小不会起伏太大。依次适用于申请分配内存空间较窄的系统。
- 首次拟合法每次都是随机分配。在不清楚用户申请空间大小的情况下，使用该方法分配空间。


同时，三种方法中，最佳拟合法相比于其它两种方式，无论是分配过程还是回收过程，都需要遍历链表，所有最费时间。

### 空间分配与回收过程产生的问题

无论使用以上三种分配方式中的哪一种，最终内存空间都会成为一个一个特别小的内存空间，对于用户申请的空间的需求，单独拿出任何一个结点都不能够满足。但是并不是说整个内存空间就不够用户使用。在这种情况下，就需要系统在回收的过程考虑将地址相邻的空闲块合并。

### 边界标识法管理动态内存

在使用边界标识法的系统管理内存时，可利用空间表中的结点的构成下表：

| head域      | llink      | tag       | size      | rlink     |
| ----------- | ---------- | --------- | --------- | --------- |
| **space域** | **space**  | **space** | **space** | **space** |
| **foot域**  | **uplink** | **tag**   |           |           |

每个结点中包含3个区域，head域、foot域和space域：

- space域表示为该内存块的大小，它的大小通过head域中的size值表示。
- head域中包含有4部分：llink和rlink分别表示指向当前内存块结点的直接前驱和直接后继。tag值用于标记当前内存块的状态，是占用块（用1表示）还是空闲块（用0表示）。size用于记录该内存块的存储大小。
- foot域中包含有2部分：uplink是指针域，用于指向内存块本身，通过uplink就可以获取该内存块所在内存的首地址。tag同head域中的tag相同，都是记录内存块状态的。

使用边界标识法的可利用空间表本身是双向循环链表，每个内存块结点都有指向前驱和后继结点的指针域。任何一个结点都可以作为该链表的头结点，当头结点为NULL时，即可利用空间表为空，无法继续分配空间。

##### 分配算法

当用户申请空间时，系统可以采用3种分配方法中的任何一种。但在不断地分配的过程中，会产生一些容量极小以至无法利用的空闲块，这些不断生成的小内存块就会减慢遍历分配的速度。针对这种情况，解决的措施是：

- 1、选定一个常量e，每次分配空间时，判断当前内存块向用户分配空间后，如果剩余部分的容量比e小，则将整个内存块全部分配给用户。
- 2、采用头部拟合法进行分配时，如果每次都从头结点指向的结点开始遍历，在若干次后，会出现存储量小的结点密集地分布在头结点结点附近的情况，严重影响遍历的时间。解决办法就是：在每次分配空间后，让头结点指针指向该分配空间结点的后继结点，然后从新的头结点指向的结点开始下一次的分配。

##### 回收算法

在用户活动完成，系统需要立即回收被用户占用的存储空间，以备新的用户使用。回收算法中需要解决的问题是：在若干次分配操作后，可利用空间块中会产生很多存储空间很小以致无法使用的空闲块。但是经过回收用户释放的空间后，可利用空间表中可能含有地址相邻的空闲块，回收算法需要将这些地址相邻的空闲块合并为大的空闲块供新的用户使用。

合并空闲块有3种情况：该空闲块的左边有相邻的空闲块可以进行合并；该空闲块的右边用相邻的空闲块可以进行合并；该空闲块的左右两侧都有相邻的空闲块可以进行合并。

判断当前空闲块左右两侧是否为空闲块的方法是：对于当前空闲块p，p-1就是相邻的低地址处的空闲块的foot域，如果foot域中的tag值为0，表明其为空闲块；p+p->size表示的是高地址处的块的head域，如果head域中的tag值为0，表明其为空闲块。

- 如果当前空闲块的左右两侧都不是空闲块，而是占用块，此种情况下只需要将新的空闲块按照相应的规则（头部拟合法随意插入，其它两种方法在对应位置插入）插入到可利用空间表中即可。
- 如果该空闲块的左侧相邻的块为空闲块，右侧为占用块，处理的方法是：只需要更改左侧空闲块中的size的大小，并重新设置左侧空闲块的foot域即可。
- 如果用户释放的内存块的相邻左侧为占用块，右侧为空闲块，处理的方法为：将用户释放掉的存储块替换掉右侧的空闲块，同时更改存储块的size和右侧空闲块的uplink指针的指向

如果当前用户释放掉的空闲块，物理位置上相邻的左右两侧的内存块全部为空闲块，需要将3个空闲块合并为一个更大的块，操作的过程为：更新左侧空闲块的size的值，同时在可利用空间表中摘除右侧空闲块，最后更新合并后的大的空闲块的foot域。此情况和只有左侧有空闲块的情况雷同，唯一的不同点是多了一步摘除右侧相邻空闲块结点的操作。

### 伙伴系统管理动态内存