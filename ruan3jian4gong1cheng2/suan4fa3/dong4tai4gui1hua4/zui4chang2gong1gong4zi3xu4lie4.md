## 最长公共子序列

### 问题描述

给定两个字符串string1和string2，返回两个字符串的最长公共子序列的长度。例如："1A2C3"，"B1D23"。则"123"是最长公共子序列，那么两字符串的最长公共子序列的长度为 3。

### 数学建模

暴力的解法可以使用排列组合。第一步、列出两个字符串所有的子序列；第二步、比较所有的子序列，找出最长公共子序列。也可以通过推导的方式，比如计算"1A2C3"和"B1D23"时，可以把问题分解成计算"1A2C3"和"B1D2"的最长公共子序列，然后在判断"B1D23"第5个字符"3"和"1A2C3"第5个字符的关系。

计算"1A2C3"和"B1D2"的最长公共子序列时因为这两个字符串末尾字符不一样，所以问题退化成（选一个字符串从末尾开始裁剪直到两个字符串末尾字符一样）计算"1A2"和"B1D2"的最长公共子序列或者计算"1A2C3"和"B1"的最长公共子序列。

### 动态规划

假设两字符串string1和string2的长度分别为m和n。可以构建一个m*n大小的矩阵`dp[][]`。其中`dp[i][j]`代表的是string1中前i个字符串与string2中前j个字符串的最长公共子序列的长度。

第一步：初始化矩阵的第一行和第一列。
- 第一行："1" 与 "B"，"B1"，"B1D"，"B1D2"，"B1D23" 分别为 0,1,1,1,1
- 第一列："B" 与 "1"，"1A"，"1A2"，"1A2C"，"1A2C3" 分别为 0,0,0,0,0

第二步：从左至右，从上至下，依次计算。这里有两种情况。
- 情况 1：`string1[i] == string2[j]`，这时 `dp[i][j] = dp[i-1][j-1] + 1`。举例："1A2" 和 "B1D2" 的最长子序列 "12" 就是 "1A" 和 "B1D" 的最长子序列 "1" 再加上 "2"。
- 情况 2：`string1[i] != string2[j]`，这时 `dp[i][j] = dp[i][j-1] 和 dp[i][j-1]` 的最大值。

|       | B    | B1   | B1D  | B1D2 | B1D23 |
| ----- | ---- | ---- | ---- | ---- | ----- |
| 1     | 0    | 1    | 1    | 1    | 1     |
| 1A    | 0    | 1    | 1    | 1    | 1     |
| 1A2   | 0    | 1    | 1    | 2    | 2     |
| 1A2C  | 0    | 1    | 1    | 2    | 2     |
| 1A2C3 | 0    | 1    | 1    | 2    | 3     |

