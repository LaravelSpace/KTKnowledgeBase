## 排序算法

时间复杂度，主要=比较次数，次要=交换次数

原地排序，空间复杂度=T(1)

稳定性，相等的元素，排序后，先后顺序不变

### 冒泡排序(BubbleSort)

时间复杂度=O(n^2^)，空间复杂度=T(1)，稳定

优化方案：

- 冒泡的时候只需要比到上一次最后交换的元素
- 如果某一次冒泡没有元素交换，则有序

### 插入排序(InsertionSort)

时间复杂度O(n^2^)，空间复杂度T(1)，稳定

实际场景使用插入排序比较多的原因是，交换次数少

### 选择排序(SelectionSort)

时间复杂度O(n^2^)，空间复杂度T(1)，不稳定

### 希尔排序(ShellSort)

分治，选择排序

时间复杂度O(n^1.3~2^)，空间复杂度T(1)，不稳定

### 归并排序(MergeSort)

分治(由下到上求解)，递归

时间复杂度O(nlog(n))，空间复杂度T(n)，稳定

### 快速排序(QuickSort)

分区(由上到下求解)，递归

平均时间复杂度O(nlog(n))​，空间复杂度T(1)

在最糟情况下，即待排序序列是有序序列时，最糟时间复杂度为O(n^2^)​

使用快排的理想情况是，落在基准数两边的元素数量差不多，所以优化方案：

- 三数取中，头中尾，取中间数做为基准，当然也可以多数取中
- 随机找一个，从概率的角度看，可以避免每次都选到最差的基准数

### 找第k大的元素

利用快排，快排每次都会把问题分为3块，[0,p-1],[p],[p+1,n-1]

比较k和p的大小就可以确定k的相对位置，时间复杂度为O(n)

### 桶排序

桶之间有序，桶内用快排

时间复杂度接近O(n)，空间复杂度T(n)

适用，外部排序，大量均匀分布的数据

避免大量的数据在一个桶中，出现这种情况要继续拆分

### 计数排序

特殊的桶排序，每个桶的跨度是1，桶里不放数据，放数据的下标

先遍历一遍序列，得到各个元素的个数，然后就可以通过计算得出各个元素在排序后的数组中的位置

把每个桶对应的元素的最后一个元素在排序后的数组中的下标放到桶里去

从后往前遍历，遇到元素就去对应的桶找位置，然后桶里的下标-1

时间复杂度O(n)，空间复杂度T(数据跨度)，稳定(从后往前的时候)

适用，数据范围不大的场景，正数

### 基数排序

适用，数据可分割成独立的位进行比较，且位之间有递进关系

比如，123,124,213,214，中比较第一位之后，百位是1的数就一定比百位是2的数小了

---

| 代码说明 | 代码位置                                 |
| -------- | ---------------------------------------- |
| 冒泡排序 | CYangLi/suan_fa/pai_xu/mao_pao_pai_xu.c  |
| 插入排序 | CYangLi/suan_fa/pai_xu/cha_ru_pai_xu.c   |
| 选择排序 | CYangLi/suan_fa/pai_xu/xuan_ze_pai_xu.c  |
| 希尔排序 | CYangLi/suan_fa/pai_xu/xi_er_pai_xu.c    |
| 归并排序 | CYangLi/suan_fa/pai_xu/gui_bing_pai_xu.c |
| 快速排序 | CYangLi/suan_fa/pai_xu/kuai_su_pai_xu.c  |